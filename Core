process.on("uncaughtException", console.error);
require("./config.js");

const fs = require('fs');
const pm2 = require('pm2');
const util = require("util");
const { promisify } = require('util');
const setTimeoutPromise = promisify(setTimeout);
const chalk = require("chalk");
const path = require('path');
const axios = require('axios');
const { spawn, exec, execSync } = require("child_process");
const moment = require("moment-timezone");
const { tiktokdl, tiktokdlv2, tiktokdlv3 } = require("@bochilteam/scraper");
const Tiktok = require("tiktokxd")
const {
  search,
  downloadTrack2,
  downloadAlbum2
} = require("@nechlophomeriaa/spotifydl");
const { TTScraper } = require('tiktok-scraper-ts');
const TikTokScraper = require('tiktok-scraper-ts');
const { EmojiAPI } = require("emoji-api");
const { addBalance } = require("./lib/limit.js");
const { smsg, formatp, tanggal, GIFBufferToVideoBuffer, formatDate, getTime, isUrl, sleep, clockString, runtime, fetchJson, getBuffer, jsonformat, format, parseMention, getRandom, fetchBuffer } = require('./lib/myfunc')
const _ = require("lodash");
const { createHash } = require('crypto');
const archiver = require('archiver');
const { LowSync, JSONFileSync } = require('./lib/lowdb')
const FileSync = require('./lib/lowdb/adapters/JSONFileSync')
const cara = "cara"

const yargs = require("yargs/yargs");
const _user = JSON.parse(fs.readFileSync('./database/bot/user.json'))
//const _register = JSON.parse(fs.readFileSync('./database/bot/registered.json'))
const ownertag = global.ownertag


let kaitime = moment.tz('Europe/Berlin').format('HH:mm:ss');
const time2 = moment().tz('Europe/Berlin').format('HH:mm:ss');
const kaidate = moment.tz('Europe/Berlin').format('DD/MM/YYYY');
const currentDate = new Date();
const options = { weekday: 'long' }; // Specify 'long' to get the full day name
const currentDay = new Intl.DateTimeFormat('de-EU', options).format(currentDate);

function updateCurrentTime() {
  kaitime = moment.tz('Europe/Berlin').format('HH:mm:ss');
}

setInterval(updateCurrentTime, 1000);


setInterval(() => {

}, 1000);


const speed = require('performance-now');
const eco = require('discord-mongoose-economy');
// const thiccysapi = require('textmaker-thiccy');
const ffmpeg = require('fluent-ffmpeg');
const ffmpegPath = require('ffmpeg-static').path;
ffmpeg.setFfmpegPath(ffmpegPath);
const Jimp = require('jimp');  // for full dp etc.
const modapk = require("tod-api");
const { hentai } = require('./lib/scraper2.js');
const { instadl } = require('./lib/instadl');
const { antispam } = require('./antispam.js')
//const ty = eco.connect('mongodb+srv://baron:baron@baron.ghhtqgv.mongodb.net/?retryWrites=true&w=majority&appName=baron');
const { limitAdd, getLimit, giveLimit, kurangBalance, getBalance, isGame, gameAdd, givegame, cekGLimit } = require('./lib/limit.js');
const githubstalk = require('./lib/githubstalk');
let { covid } = require('./lib/covid.js');
const { Gempa } = require("./lib/gempa.js");
const { PhoenixTiktok } = require('./lib/tiktokdl');
const spaceemojis = ["🌌", "🌠", "🚀", "🪐", "🌟"];     // list of emojis for Space CMDs.
const manyemojis = ["😄", "👍", "👏", "👌", "🥇", "🌟", "🎉", "🙌", "🤩", "💯", "🔥", "✨", "🚀", "💖", "🌈", "🌞", "🌠", "🌼", "💪", "😎", "💫", "💓", "🎈", "🎁", "🍾", "🎊", "🥳", "👑", "🌺", "🌻", "🌸"];
const os = require('os');
// for os info

const gis = require("g-i-s");
const {
  default: PhoenixConnect,
  useMultiFileAuthState,
  DisconnectReason,
  fetchLatestBaileysVersion,
  generateForwardMessageContent,
  prepareWAMessageMedia,
  generateWAMessageFromContent,
  generateMessageID,
  downloadContentFromMessage,
  makeInMemoryStore,
  jidDecode,
  proto,
  MessageType
} = require("@whiskeysockets/baileys");




/********** UTILS **********/
const { daily, level, register, afk, reminder, premium, } = require('./function')

const cd = 4.32e+7
const limitCount = 25
const errorImg = 'https://i.ibb.co/jRCpLfn/user.png'
/********** END OF UTILS **********/

/********** DATABASES **********/
const _antilink = JSON.parse(fs.readFileSync('./database/group/antilink.json'))
const _antinsfw = JSON.parse(fs.readFileSync('./database/group/antinsfw.json'))
const _leveling = JSON.parse(fs.readFileSync('./database/group/leveling.json'))
const _welcome = JSON.parse(fs.readFileSync('./database/group/welcome.json'))
const _autosticker = JSON.parse(fs.readFileSync('./database/group/autosticker.json'))
const _badwords = JSON.parse(fs.readFileSync('./database/group/badwords.json'))
const _ban = JSON.parse(fs.readFileSync('./database/bot/banned.json'))
const _premium = JSON.parse(fs.readFileSync('./database/bot/premium.json'))
const _mute = JSON.parse(fs.readFileSync('./database/bot/mute.json'))
const _registered = JSON.parse(fs.readFileSync('./database/bot/registered.json'))
const _level = JSON.parse(fs.readFileSync('./database/user/level.json'))
let _limit = JSON.parse(fs.readFileSync('./database/user/limit.json'))
const _afk = JSON.parse(fs.readFileSync('./database/user/afk.json'))
const _reminder = JSON.parse(fs.readFileSync('./database/user/reminder.json'))
const _daily = JSON.parse(fs.readFileSync('./database/user/daily.json'))
const _backup = ('./database');
const _setting = JSON.parse(fs.readFileSync('./database/bot/setting.json'))
//const importFresh = require('import-fresh');

// Konstruiere den absoluten Pfad zur eng.js-Datei
//const engFilePath = path.join(__dirname, 'message', 'text', 'lang', 'eng.js');

// Lade die Datei mit import-fresh
//const eng = importFresh(engFilePath);



let { memberLimit, groupLimit } = _setting
/********** END OF DATABASES **********/

//"parse-ms": "^1.1.0",

const time0 = kaitime
//
let nowtime = '';

if (time0 < "05:00:00") {
  nowtime = '𝘎𝘜𝘛𝘌𝘕 𝘔𝘖𝘙𝘎𝘌𝘕';
} else if (time0 < "11:00:00") {
  nowtime = '𝘎𝘜𝘛𝘌𝘕 𝘔𝘖𝘙𝘎𝘌𝘕';
} else if (time0 < "15:00:00") {
  nowtime = '𝘎𝘜𝘛𝘌𝘕 𝘛𝘈𝘎';
} else if (time0 < "18:00:00") {
  nowtime = '𝘎𝘜𝘛𝘌𝘕 𝘈𝘉𝘌𝘕𝘋';
} else if (time0 < "19:00:00") {
  nowtime = '𝘎𝘜𝘛𝘌𝘕 𝘈𝘉𝘌𝘕𝘋';
} else {
  nowtime = '𝘎𝘜𝘛𝘌 𝘕𝘈𝘊𝘏𝘛';
}




//
const timestampe = speed();
const latensie = speed() - timestampe

var low;
try {
  low = require("lowdb");
} catch (e) {
  low = require("./lib/lowdb");
}

const { Low, JSONFile } = low;
const mongoDB = require("./lib/mongoDB");

global.opts = new Object(
  yargs(process.argv.slice(2)).exitProcess(false).parse()
);
global.db = new Low(
  /https?:\/\//.test(opts["db"] || "")
    ? new cloudDBAdapter(opts["db"])
    : /mongodb/.test(opts["db"])
      ? new mongoDB(opts["db"])
      : new JSONFile(`src/database.json`)
);
global.DATABASE = global.db; // Backwards Compatibility
global.loadDatabase = async function loadDatabase() {
  if (global.db.READ)
    return new Promise((resolve) =>
      setInterval(function () {
        !global.db.READ
          ? (clearInterval(this),
            resolve(
              global.db.data == null ? global.loadDatabase() : global.db.data
            ))
          : null;
      }, 1 * 1000)
    );
  if (global.db.data !== null) return;
  global.db.READ = true;
  await global.db.read();
  global.db.READ = false;
  global.db.data = {
    users: {},
    chats: {},
    database: {},
    game: {},
    settings: {},
    others: {},
    sticker: {},
    ...(global.db.data || {}),
  };
  global.db.chain = _.chain(global.db.data);
};
loadDatabase();
global.db = JSON.parse(fs.readFileSync("./src/database.json"));
if (global.db)
  global.db = {
    sticker: {},
    database: {},
    game: {},
    others: {},
    users: {},
    ...(global.db || {}),
  };
///////////////

///////////////


//
let isSleeping = false; // Move the declaration here.
let banUser = JSON.parse(fs.readFileSync('./database/banUser.json'));
let banchat = JSON.parse(fs.readFileSync('./database/banChat.json'));

let ntnsfw = JSON.parse(fs.readFileSync('./database/nsfw.json')); //
let pendaftar = JSON.parse(fs.readFileSync('./storage/user/user.json'))
let balance = JSON.parse(fs.readFileSync('./database/balance.json'))
let ssewa = JSON.parse(fs.readFileSync('./database/sewa.json'))
let ban = JSON.parse(fs.readFileSync('./database/ban.json'))
let limit = JSON.parse(fs.readFileSync('./database/limit.json'))
global.db = JSON.parse(fs.readFileSync('./src/database.json'))
let _sewa = require("./lib/sewa");


const sewa = JSON.parse(fs.readFileSync('./database/sewa.json'))
const time = moment.tz('Europe/Berlin').format('DD/MM HH:mm:ss')
const ucap = moment(Date.now()).tz('Europe/Berlin').locale('id').format('a')
var buln = ['/01/', '/02/', '/03/', '/04/', '/05/', '/06/', '/07/', '/08/', '/09/', '/10/', '/11/', '/12/'];
var myHari = ['Sonntag', 'Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag', 'Samstag'];
var tgel = new Date();
var hri = tgel.getDate();
var bulnh = tgel.getMonth();
var thisHari = tgel.getDay(),
  thisDaye = myHari[thisHari];
var yye = tgel.getYear();
var syear = (yye < 1000) ? yye + 1900 : yye;
const jangwak = (hri + '' + buln[bulnh] + '' + syear)
const janghar = (thisDaye)
var myHari = [
  "Sonntag",
  "Montag",
  "Dienstag",
  "Mittwoch",
  "Donnerstag",
  "Freitag",
  "Samstag",
];
var tgel = new Date();
var thisHari = tgel.getDay(),
  thisDaye = myHari[thisHari];
var yye = tgel.getYear();



//
module.exports = Phoenix = async (Phoenix, m, chatUpdate, store) => {
  try {
    var body = (m.mtype === 'conversation') ? m.message.conversation : (m.mtype == 'imageMessage') ? m.message.imageMessage.caption : (m.mtype == 'videoMessage') ? m.message.videoMessage.caption : (m.mtype == 'extendedTextMessage') ? m.message.extendedTextMessage.text : (m.mtype == 'buttonsResponseMessage') ? m.message.buttonsResponseMessage.selectedButtonId : (m.mtype == 'listResponseMessage') ? m.message.listResponseMessage.singleSelectreply.selectedRowId : (m.mtype == 'templateButtonreplyMessage') ? m.message.templateButtonreplyMessage.selectedId : m.mtype === 'InteractiveResponseMessage' ? JSON.parse(m.message.interactiveResponseMessage.nativeFlowResponseMessage.paramsJson)?.id : (m.mtype === 'messageContextInfo') ? (m.message.buttonsResponseMessage?.selectedButtonId || m.message.listResponseMessage?.singleSelectreply.selectedRowId || m.message.InteractiveResponseMessage.NativeFlowResponseMessage || m.text) : ''
    var budy = (typeof m.text == 'string' ? m.text : '')
    const {
      type,
      quotedMsg,
      mentioned,
      now,
      fromMe
    } = m
    const prefix = global.prefa
    const id = m.sender
    const isCmd = body.startsWith(prefix)
    const notCmd = body.startsWith('')
    const command = isCmd ? body.slice(1).trim().split(' ')[0].toLowerCase() : ''
    const args = body.trim().split(/ +/).slice(1)
    const pushname = m.pushName || "No Name"
    const botNumber = await Phoenix.decodeJid(Phoenix.user.id)
    
    const isCreator = [botNumber, ...global.Owner].map(v => v.replace(/[^0-9]/g, '') + '@s.whatsapp.net').includes(m.sender)
    global.iscreator = isCreator
    const isSup = [botNumber, ...global.sup].map(v => v.replace(/[^0-9]/g, '') + '@s.whatsapp.net').includes(m.sender)
    const itsMe = m.sender == botNumber ? true : false
    const text = args.join(" ")
    const from = m.chat
    const quoted = m.quoted ? m.quoted : m
    const mime = (quoted.msg || quoted).mimetype || ''
    const isMedia = /image|video|sticker|audio/.test(mime)
    const isImage = (type == 'imageMessage')
    const isVideo = (type == 'videoMessage')

    const isAudio = (type == 'audioMessage')
    const isText = (type == 'textMessage')
    const isSticker = (type == 'stickerMessage')
    const isQuotedText = type === 'extendexTextMessage' && content.includes('textMessage')
    const isQuotedImage = type === 'extendedTextMessage' && content.includes('imageMessage')
    const isQuotedLocation = type === 'extendedTextMessage' && content.includes('locationMessage')
    const isQuotedSticker = type === 'extendedTextMessage' && content.includes('stickerMessage')
    const isQuotedContact = type === 'extendedTextMessage' && content.includes('contactMessage')
    const isQuotedDocument = type === 'extendedTextMessage' && content.includes('documentMessage')
    const sticker = []
    const messagesD = body.slice(0).trim().split(/ +/).shift().toLowerCase()
    const groupMetadata = m.isGroup ? await Phoenix.groupMetadata(m.chat).catch(e => { }) : ''
    const groupName = m.isGroup ? groupMetadata?.subject : ''
    const participants = m.isGroup ? await groupMetadata.participants : ''
    const groupAdmins = m.isGroup ? await participants.filter(v => v.admin !== null).map(v => v.id) : ''
    const groupOwner = m.isGroup ? groupMetadata.owner : ''
    const isBotAdmins = m.isGroup ? groupAdmins.includes(botNumber) : false
    const isAdmins = m.isGroup ? groupAdmins.includes(m.sender) : false
    global.isadmins = isAdmins
    const isUser = pendaftar.includes(m.sender)
    const isBan = banUser.includes(m.sender)
    const welcm = m.isGroup ? wlcm.includes(from) : false
    const isBanChat = m.isGroup ? banchat.includes(from) : false
    const isRakyat = isCreator || global.rkyt.map(v => v.replace(/[^0-9]/g, '') + '@s.whatsapp.net').includes(m.sender) || false
    const AntiLink = m.isGroup ? ntilink.includes(from) : true
    const AntiLinkYoutubeVid = m.isGroup ? ntilinkytvid.includes(from) : false
    const AntiLinkYoutubeChannel = m.isGroup ? ntilinkytch.includes(from) : false
    const AntiLinkInstagram = m.isGroup ? ntilinkig.includes(from) : false
    const AntiLinkFacebook = m.isGroup ? ntilinkfb.includes(from) : false
    const AntiLinkTiktok = m.isGroup ? ntilinktt.includes(from) : false
    const AntiLinkTelegram = m.isGroup ? ntilinktg.includes(from) : false
    const AntiLinkTwitter = m.isGroup ? ntilinktwt.includes(from) : false
    const AntiLinkAll = m.isGroup ? ntilinkall.includes(from) : true
    const antiWame = m.isGroup ? ntwame.includes(from) : false
    const antiVirtex = m.isGroup ? ntvirtex.includes(from) : false
    const AntiNsfw = m.isGroup ? ntnsfw.includes(from) : false

    const changelog = `
🆕🤖 *UPDATES des Bots PhoenixBots*
Datum des Updates: 11.07.2024 12:00 Uhr

🔹 Verbesserung von AntiSpam (${prefix}antispam)
🔹 Einführung von einer DSGVO (${prefix}dsgvo)
🔹 Einführung vom TNC-System (${prefix}tnc)

⚠️ Die obigen Befehle befinden sich derzeit noch in der *BETA Phase!* Das bedeutet, dass die Befehle möglicherweise noch nicht zu 100% funktionieren.

`

    const dsgvoPolicy =   `

    📊🔒 -----[ DATEN ]----- 🔒📊

    ⚠️ Wir speichern Daten.
    Das Speichern von Daten ist notwendig, um viele Funktionen des Bots anzubieten.
    
    Folgende Daten werden gespeichert (Datenbank):
    
    1️⃣ >> AFK (Bei Benutzung, nach Ablauf automatische Löschung)
    📞 Rufnummer; Text; Zeitpunkt der Nachricht
    
    2️⃣ >> Bannstatus (Bei Bann, bleiben erhalten, um Missbrauch zu verhindern)
    📞 Rufnummer; Banngrund; Ersteller; Zeitpunkt der Erstellung
    
    3️⃣ >> Erinnerung (Bei Benutzung, nach Ablauf automatische Löschung)
    📞 Rufnummer; Text; Ablaufdatum
    
    4️⃣ >> GruppenInfo (Entsprechende Gruppe wird beim Verlassen (${prefix}leave) automatisch gelöscht)
    🆔 GruppenID; Gruppenspezifische Funktionen (Ein/Aus)
    
    5️⃣ >> Premium (Nur beim Besitz von Premium, nach Ablauf automatische Löschung)
    📞 Rufnummer; Ablaufdatum
    
    6️⃣ >> Level (Wird automatisch erstellt beim ersten Befehl)
    📞 Rufnummer; Level; XP
    
    7️⃣ >> LogBefehle (Werden für Fehlerdiagnosen gespeichert und nach manueller Diagnose gelöscht)
    🆔 GruppenID; Rufnummer; Befehl; Zeitpunkt
    📵 Nachrichten außerhalb von Befehlen werden nicht gespeichert. Chatverläufe werden 1-2x pro Woche beim Bot (WhatsApp) gelöscht.
    
    8️⃣ >> Registrierung
    📞 Rufnummer; Name; Alter; Zeitpunkt der Registrierung; Serial
    
    9️⃣ >> Support (Bei Benutzung steigt der Wert um +1)
    🆔 SupportID
    
    🔟 >> Vorstellung
    Solltest du dich bei einem Admin vorgestellt haben (${prefix}vt), werden folgende Daten erhoben:
    📝 Name; Alter; Ort; 🖼️ Bild (wenn angegeben)
    Zum Löschen dieser Informationen, verwende ${prefix}vt delete
    
    = = = = = = = = = = = = = = = =
    
    ❓💡 *Ihr möchtet eure Daten löschen?*
    ${prefix}unregister
     - Löscht Informationen im Punkt #Registrierung
       (Ermöglicht eine neue Registrierung mit anderen Angaben zum Namen & Alter)
    ${prefix}datadelete
     - Löscht alle Informationen außer #Bannstatus, #LogBefehle und temporäre Daten wie z. B. #AFK
    
    Gebannte Nutzer, deren Daten gelöscht werden sollen, melden sich bitte mit ihrer Rufnummer bei:
    ${prefix}owner
    Hierbei wird die Löschung manuell durchgeführt, wie beim Befehl ${prefix}datadelete.
    
    ⚙️ Eine technische Lösung zur automatischen Löschung von Daten ist in Planung.
    
    = = = = = = = = = = = = = = = =
    
    ❓📜 Ihr möchtet Einsicht in eure gespeicherten Daten?
    Meldet euch bei uns mit ${prefix}support und nennt uns die gewünschten Daten.
    
    ⚙️ Eine automatische Funktion über einen Befehl zur Auskunft der Daten ist in Planung.
    
    Stand: 07/2024
    
    `

    const privacyPolicy = `
🔒 *❖ Phoenix Bot Datenschutzrichtlinie, Nutzungsbedingungen ❖* 🔒

*◉ [ Datenschutzerklärung ]*
1️⃣ Phoenix-Bot zeichnet keine Benutzer-Chat-Verlaufsdaten auf.
2️⃣ Phoenix-Bots geben keine Benutzer-IDs weiter.
3️⃣ Phoenix-Bot speichert keine vom Benutzer übermittelten Medien.
4️⃣ Phoenix-Bot wird Benutzerdaten nicht missbrauchen.
5️⃣ Der Phoenix-Bot-Eigentümer hat das Recht, die Chat-Verlaufsdaten des Benutzers einzusehen.
6️⃣ Der Phoenix-Bot-Eigentümer hat die Berechtigung, den Status des Benutzers anzuzeigen.
7️⃣ Phoenix-Bot-Eigentümer können den Chat-Verlauf und die von Benutzern gesendeten Medien anzeigen.

*◉ [ Phoenix-Bot Regeln ]*
1️⃣ Benutzern ist es untersagt, Bot-Nummern anzurufen oder per Videoanruf anzurufen.
2️⃣ Benutzern ist es untersagt, verschiedene Bugs, Virtexe usw. an die Bot-Nummer zu senden.
3️⃣ Von den Benutzern wird erwartet, dass sie bei der Verwendung von Bots nicht spammen.
4️⃣ Benutzern ist es untersagt, Bot-Nummern illegal hinzuzufügen. Wenden Sie sich zum Hinzufügen bitte an den Eigentümer.
5️⃣ Von den Benutzern wird erwartet, dass sie die Bot-Funktionen nicht missbrauchen.

*◉ [ Phoenix Bot-Nutzungsbedingungen ]*
1️⃣ Der Bot verlässt die Gruppe bei Nichterfüllung der Vorraussetzungen von 15 Teilnehmern.
2️⃣ Phoenix-Bot kann Benutzer einseitig sperren, wenn es sich um einen falschen Benutzer handelt.
3️⃣ Der Phoenix-Bot führt die Bot-Funktion aus.
4️⃣ Phoenix-Bot wird Strafen verhängen: Benutzer sperren oder sperren, die gegen die Regeln verstoßen.
5️⃣ Phoenix-Bot ist verantwortlich für schwerwiegende Fehler in der Programmierung und Besitzer.

-Phoenix-Bot 🌌
-Phillip V. 👤
Verordnung: 27. November 2022 📅
`

    autoreadsw = true
    const content = JSON.stringify(m.message)
    const q = args.join(' ')

    const isQuotedVideo = m.mtype === 'extendedTextMessage' && content.includes('videoMessage')
    const isQuotedAudio = m.mtype === 'extendedTextMessage' && content.includes('audioMessage')
    /********** VALIDATOR **********/

   



    const {
      addRegisteredUser,
      checkRegisteredUser,
      isUserNotRegistered,
      checkRegisteredUserFromSerial,
      getRegisteredNameFromSerial,
      getRegisteredTimeFromSerial,
      getRegisteredIdFromSerial,
      getRegisteredRandomId,
      getRegisteredUserId,
      getRegisteredPosition
    } = require('./function/register')
    const {
      getLevelingId,
      getLevelingLevel,
      getLevelingXp,
      addLevelingLevel,
      addLevelingXp,
      getUserRank,
      isGained,
      addCooldown


    } = require('./function/level')

    const { canLevelUp, findLevel } = require('./lib/levelling.js');
    const { levelup } = require('./lib/canvas.js');


    // Funktion zum Erstellen einer ZIP-Datei des "database"-Ordners
    const createDatabaseZip = (zipPath) => {
      return new Promise((resolve, reject) => {
        const output = fs.createWriteStream(zipPath);
        const archive = archiver('zip', { zlib: { level: 9 } });

        output.on('close', () => resolve());
        archive.on('error', (err) => reject(err));

        archive.pipe(output);
        archive.directory('./database/', 'database');
        archive.finalize();
      });
    };
    const isLeveling = false
    const isRegistered = register.checkRegisteredUser(m.sender, _registered)
    const _dir = JSON.parse(fs.readFileSync('./database/bot/registered.json'))


    /********** END OF VALIDATOR **********/

    function deleteCache() {
      const directoryPath = './bot_api';
      const files = fs.readdirSync(directoryPath);
      const filesToDelete = files.filter(file => file !== 'creds.json');

      filesToDelete.forEach(file => {
        const filePath = path.join(directoryPath, file);
        fs.unlinkSync(filePath);
        console.log(`${filePath} erfolgreich gelöscht!`);
      });
    }


    function restartProcess() {
      console.log('Der Prozess wird neu gestartet...');
      process.exit();
    }

    function scheduleRestart() {


      setInterval(() => {
        deleteCache();
        restartProcess();
      }, 3600000); // 1 Stunde
    }

    scheduleRestart();

    /********** END OF VALIDATOR **********/
    ///////////////////////////

    //console.log('Nachricht', m);
    //console.log('Prefix:', isCmd);

    ////////////////


    const filePathh = './database/bot/registered.json';
    const updatedDataa = require(filePathh);
    const numberOfUserss = Object.keys(updatedDataa).length;
    const loll = numberOfUserss
    // Funktion zum Laden der Datei und Ausführen von Aktionen nach einem Update
    const updateFile = () => {
      console.log(chalk.redBright(`Update ${filePathh}`));

      // Lade die aktualisierte Datei
      const updatedData = require(filePathh);


      const numberOfUsers = Object.keys(updatedData).length;


      console.log(`Anzahl der Registrierten User: ${numberOfUsers}`);
    };


    // Funktion zum Starten des Dateiüberwachung
    const startFileWatcher = () => {
      // Überwache die Datei auf Änderungen
      fs.watch(filePathh, (eventType, filename) => {
        if (eventType === 'change') {
          // Wenn sich die Datei ändert, führe die Update-Funktion aus
          updateFile();
        }
      });
    };

    // Starte den Updater
    startFileWatcher();
    //============================//
    const dbPath = './database/user/level.json';

    // Sicherstellen, dass die globale Datenbank initialisiert wird
    global.db = global.db || {};
    global.db.data = global.db.data || { users: {}, chats: {}, stats: {}, msgs: {}, sticker: {}, settings: {} };

    // Daten aus Datei laden oder initialisieren
    function loadDatabase() {
      try {
        const data = fs.readFileSync(dbPath, 'utf-8');
        global.db.data.users = JSON.parse(data);
      } catch (error) {
        console.error('Fehler beim Laden der Datenbank:', error);
        global.db.data.users = {};
      }
    }

    // Daten in Datei speichern
    function saveDatabase() {
      try {
        fs.writeFileSync(dbPath, JSON.stringify(global.db.data.users, null, 4));
        // console.log('Daten erfolgreich in die Datei geschrieben.');
      } catch (error) {
        console.error('Fehler beim speichern der Datei:', error);
      }
    }
    // Benutzer abrufen oder erstellen und aktualisieren
    function getUserData(sender) {
      if (!global.db.data.users[sender]) {
        global.db.data.users[sender] = { exp: 0, level: 1, role: global.rolee(1).name };
      }
      return global.db.data.users[sender];
    }

    // Datenbank laden beim Start
    loadDatabase();

    function updateUser(m, isCmd) {
      try {
        let userr = global.db.data.users[m.sender];
        if (!userr) {
          userr = global.db.data.users[m.sender] = { exp: 0, level: 1, role: global.rolee(1).name };
        }

        let expPoints = Math.floor(Math.random() * 25) + 10; // 25-50 für Nachrichten
        if (isCmd) expPoints += Math.floor(Math.random() * 60) + 30; // 50-100 für Befehle
        userr.exp += expPoints;

        // Level up Logik
        while (userr.exp >= 1000) { // Level up bei jeder 1000 XP
          userr.level++;
          userr.exp -= 1000;
        }

        // Rolle aktualisieren
        userr.role = global.rolee(userr.level).name;

        // Datenbank speichern
        saveDatabase();

        //console.log(userr);
      } catch (error) {
        console.error('Fehler beim Aktualisieren des Benutzers:', error);
      }
    }

    // Beispielaufruf
    updateUser(m, isCmd);


    function xpRange(level, multiplier = global.multiplier || 1) {
      if (level < 0) throw new TypeError('Level cannot be negative value');
      level = Math.floor(level);
      let min = level === 0 ? 0 : Math.round(Math.pow(level, global.xpGrowth) * multiplier) + 1;
      let max = Math.round(Math.pow(++level, global.xpGrowth) * multiplier);
      return { min, max, xp: max - min };
    }

    function sort(property, ascending = true) {
      return (a, b) => ascending ? a[property] - b[property] : b[property] - a[property];
    }

    function toNumber(property, _default = 0) {
      return (a) => a[property] === undefined ? _default : a[property];
    }

    function enumGetKey(a) {
      return a.jid;
    }

    function getNextRank(level) {
      let arr = Object.keys(global.multiplier);
      let position = false;
      for (let key of arr) {
        if (level <= key) {
          position = key;
          break;
        }
      }
      return position !== false ? arr[position] : null;
    }



    //============================//
    if (m.mtype === "interactiveResponseMessage") {
      console.log("interactiveResponseMessage Detected!")
      let msg = m.message[m.mtype] || m.msg
      if (msg.nativeFlowResponseMessage && !m.isBot) {
        let { id } = JSON.parse(msg.nativeFlowResponseMessage.paramsJson) || {}
        if (id) {
          let emit_msg = {
            key: { ...m.key },
            message: { extendedTextMessage: { text: id } },
            pushName: m.pushName,
            messageTimestamp: m.messageTimestamp || 754785898978
          }
          return Phoenix.ev.emit("messages.upsert", { messages: [emit_msg], type: "notify" })
        }
      }
    }
    //=======================================
    const fsp = fs.promises;



    // Pfade zu den JSON-Dateien
    const USER_CHATS_FILE = path.join(__dirname, 'database/user/userchats.json');
    const GROUP_CHATS_FILE = path.join(__dirname, 'database/group/groupchats.json');

    // Funktion zur Initialisierung der JSON-Dateien, falls sie nicht existieren
    const initializeFiles = async () => {
      try {
        // Sicherstellen, dass die Benutzerchats-Datei existiert
        await fsp.mkdir(path.dirname(USER_CHATS_FILE), { recursive: true });
        try {
          await fsp.access(USER_CHATS_FILE);
        } catch {
          await fsp.writeFile(USER_CHATS_FILE, JSON.stringify({ users: [] }, null, 4));
        }

        // Sicherstellen, dass die Gruppenchats-Datei existiert
        await fsp.mkdir(path.dirname(GROUP_CHATS_FILE), { recursive: true });
        try {
          await fsp.access(GROUP_CHATS_FILE);
        } catch {
          await fsp.writeFile(GROUP_CHATS_FILE, JSON.stringify({ groups: [] }, null, 4));
        }
      } catch (error) {
        console.error("Fehler bei der Initialisierung der Dateien:", error);
      }
    };

    // Funktion zum Laden der Daten aus einer JSON-Datei
    const loadData = async (filePath) => {
      try {
        const data = await fsp.readFile(filePath, 'utf8');
        return JSON.parse(data);
      } catch (error) {
        console.error(`Fehler beim Laden der Daten aus ${filePath}:`, error);
        return null;
      }
    };

    // Funktion zum Speichern der Daten in einer JSON-Datei
    const saveData = async (filePath, data) => {
      try {
        await fsp.writeFile(filePath, JSON.stringify(data, null, 4));
      } catch (error) {
        console.error(`Fehler beim Speichern der Daten in ${filePath}:`, error);
      }
    };

    // Funktion zum Hinzufügen einer Benutzer-ID
    const addUserId = async (userId) => {
      let userChats = await loadData(USER_CHATS_FILE);
      if (!userChats || !Array.isArray(userChats.users)) {
        console.error("Fehler: Benutzerchats-Daten sind ungültig.");
        userChats = { users: [] };
      }

      if (!userChats.users.includes(userId)) {
        userChats.users.push(userId);
        await saveData(USER_CHATS_FILE, userChats);
      }
    };

    // Funktion zum Hinzufügen einer Gruppen-ID
    const addGroupId = async (groupId) => {
      let groupChats = await loadData(GROUP_CHATS_FILE);
      if (!groupChats || !Array.isArray(groupChats.groups)) {
        console.error("Fehler: Gruppenchat-Daten sind ungültig.");
        groupChats = { groups: [] };
      }

      // Überprüfen, ob die Gruppen-ID mit "@g.us" endet
      if (groupId.endsWith('@g.us') && !groupChats.groups.includes(groupId)) {
        groupChats.groups.push(groupId);
        await saveData(GROUP_CHATS_FILE, groupChats);
      }
    };

    // Funktion zum Abrufen der Anzahl der Benutzer- und Gruppenchats
    const getChatCounts = async () => {
      const userChats = await loadData(USER_CHATS_FILE);
      const groupChats = await loadData(GROUP_CHATS_FILE);

      return {
        userCount: userChats && Array.isArray(userChats.users) ? userChats.users.length : 0,
        groupCount: groupChats && Array.isArray(groupChats.groups) ? groupChats.groups.length : 0
      };
    };

    // Initialisierung der JSON-Dateien
    initializeFiles()
      .then(async () => {
        // Beispielhafte Verwendung der Funktionen
        await addUserId(m.sender);
        await addGroupId(m.chat);
        const counts = await getChatCounts();
        // console.log('Anzahl der Benutzerchats:', counts.userCount);
        // console.log('Anzahl der Gruppenchats:', counts.groupCount);
      })
      .catch(console.error);
    const counts = await getChatCounts();






    //=======================================

    // Datei laden oder leeren Array initialisieren, wenn Datei nicht existiert
    const antilinkPath = './database/group/antilink.json';

    let antilinkData;
    try {
      antilinkData = JSON.parse(fs.readFileSync(antilinkPath));
    } catch (error) {
      antilinkData = [];
    }

    function saveAntilinkData() {
      fs.writeFileSync(antilinkPath, JSON.stringify(antilinkData, null, 2));
    }


    let privateChatData = { groups: [] };

    // Funktion zum Laden der JSON-Datei
    function loadPrivateChatData() {
      try {
        // Prüfen, ob die Datei existiert, falls nicht, eine neue Datei mit Standardwerten erstellen
        if (!fs.existsSync('./database/group/privatechat.json')) {
          fs.writeFileSync('./database/group/privatechat.json', JSON.stringify({ groups: [] }, null, 2));
        }

        // Datei lesen
        let data = fs.readFileSync('./database/group/privatechat.json', 'utf8');

        // JSON parsen und Struktur überprüfen
        privateChatData = JSON.parse(data);
        if (!Array.isArray(privateChatData.groups)) {
          privateChatData.groups = [];
        }
      } catch (error) {
        console.error('Fehler beim Laden der privaten Chat-Daten:', error);
        privateChatData = { groups: [] };
      }
    }

    // Daten beim Start des Bots laden
    loadPrivateChatData();


    const pathh = './database/group/welcome.json';


    function loadGroupEvents() {
      try {
        return JSON.parse(fs.readFileSync(pathh, 'utf8'));
      } catch (err) {
        return {}; // Return an empty object if file doesn't exist or can't be read
      }
    }

    function saveGroupEvents(groupEvents) {
      fs.writeFileSync(pathh, JSON.stringify(groupEvents, null, 2));
    }

    // Load group events when the bot starts
    global.groupEvents = loadGroupEvents();

    // Modus setzen, wenn Gruppen gespeichert sind
    if (privateChatData.groups && privateChatData.groups.length > 0) {
      Phoenix.public = false;
      Phoenix.private = true;
    } else {
      Phoenix.public = true;
      Phoenix.private = false;
    }
    async function loading() {
      var baronlod = [
        "《 █▒▒▒▒▒▒▒▒▒▒▒》10%",
        "《 ████▒▒▒▒▒▒▒▒》30%",
        "《 ███████▒▒▒▒▒》50%",
        "《Hail Exiqon》",
        "《Hail Baron》",
        "《 ██████████▒▒》80%",
        "《 ████████████》100%",
        "𝙻𝙰𝙳𝙴𝚅𝙾𝚁𝙶𝙰𝙽𝙶 𝙴𝚁𝙵𝙾𝙻𝙶𝚁𝙴𝙸𝙲𝙷!"
      ]
      let { key } = await Phoenix.sendMessage(from, { text: 'ʟᴏᴀᴅɪɴɢ...' })

      for (let i = 0; i < baronlod.length; i++) {
        await Phoenix.sendMessage(from, { text: baronlod[i], edit: key });
      }
    }
    ////////////////////////////
    autoreadsw = true;
    _sewa.expiredCheck(Phoenix, sewa);

    const reply = (teks) => {
      Phoenix.sendMessage(m.chat, { text: teks }, { quoted: m })
    }


    /* const reply = (teks) => {
      Phoenix.sendMessage(m.chat, { text: teks }, { quoted: m }); 
    }; */


    const sender = m.isGroup ? (m.key.participant ? m.key.participant : m.participant) : m.key.remoteJid
    const senderNumber = sender.split('@')[0]

    function randomNomor(angka) {
      return Math.floor(Math.random() * angka) + 1;
    }
    // Anti-Spam
    const cooldown = 30000;
    if (global.antispam) {
     // console.log('1')
     // console.log('m.isGroup' , m.isGroup)
     // console.log('m.chat  ', m.chat)
     // console.log('antispam.isFiltered(m.sender)  ', antispam.isFiltered(m.sender))
      if (m.isGroup && m.chat && antispam.isFiltered(m.sender)) {
        console.log('2')
        console.log(`[SPAM]`, color(moment(m.messageTimestamp * 100).format('DD/MM/YYYY HH:mm:ss'), 'yellow'), color(`${command} [${args.length}]`), 'from', color(m.pushname));
        console.log('3')
        const ignoredUntil = Date.now() + cooldown;
        console.log('4')
        db.data.users[from].ignoreUntil = ignoredUntil;

        await Phoenix.sendMessage(m.chat, `Du wurdest für ${cooldown / 1000} Sekunden gesperrt, weil du spamst.`);

        return;
      }
    }



    
    if (m.message) {
      addBalance(m.sender, randomNomor(574), balance);

      const messageType = budy || m.mtype;
      const from = m.isGroup ? 'Gruppe: ' + groupName : 'Private Chat';
      const chatName = m.isGroup ? pushname : pushname;
      const inChat = m.chat;

      // Erstelle eine strukturierte und farbige Konsolenausgabe
      if (isCmd) {
        console.log(
          chalk.white(chalk.bgBlack("[ COMMAND ]")),
          "\n" +
          chalk.magenta("=> From:") + " " +
          chalk.blue(chatName) + " (" + chalk.yellow(m.sender) + ")" + "\n" +
          chalk.magenta("=> Type:") + " " +
          chalk.cyan(messageType) + "\n" +
          chalk.magenta("=> In:") + " " +
          chalk.red(from) + " (" + chalk.green(inChat) + ")"
        );
      }
    }      



    if (isCmd && !isUser) {
      pendaftar.push(m.sender);
      fs.writeFileSync("./storage/user/user.json", JSON.stringify(pendaftar));
    }





    //----------------------------------------------------------------------------------------------------------//
    
    /*
    if (global.autoReadAll = true) {
      
      
        
    
          const lastMsgInChat = await getLastMessageInChat(m.chat);

          await Phoenix.chatModify(
            { markRead: true, lastMessages: [lastMsgInChat] }, m.chat
          );

      
      
    } */

    if (global.autoreadgc) {
      if (command) {
        await Phoenix.sendPresenceUpdate('composing', m.chat);

        // Create an array of message keys to mark as read
        const keysToMarkAsRead = [
          {
            remoteJid: m.chat,
            id: m.key.id,
            participant: m.sender,
          },
          // You can add more message keys to mark multiple messages as read
        ];

        // Use the sock object to read the specified messages
        await Phoenix.readMessages(keysToMarkAsRead);
      }
    }


    if (global.autoRecord) {
      if (m.chat) {
        Phoenix.sendPresenceUpdate("recording", m.chat);
      }
    }

    if (global.autoTyping) {
      if (m.chat) {
        Phoenix.sendPresenceUpdate("composing", m.chat);
      }
    }

    if (global.available) {
      if (m.chat) {
        Phoenix.sendPresenceUpdate("available", m.chat);
      }
    }





    //don't edit this part.
    const formatTime = (seconds) => {
      const hours = Math.floor(seconds / 3600);
      const minutes = Math.floor((seconds % 3600) / 60);
      const secs = seconds % 60;
      return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    };

    function updateStatus() {
      const uptimeInSeconds = Math.floor(process.uptime());
      const uptimeFormatted = formatTime(uptimeInSeconds);

      // Set the status using Phoenix.setStatus or your equivalent method

      // Update the status randomly within 5 minutes (300000 milliseconds)
      const randomTime = Math.floor(Math.random() * 300000) + 1000; // don't edit.
      setTimeout(updateStatus, randomTime);
    }

    // Initial call to start the random status updates
    updateStatus();

    // Annahme: isBotAdmins, isAdmins, m.key.fromMe, isCreator sind definierte Variablen




    if (AntiLinkAll) {
      const linkRegex = /(?:^|\s)whatsapp\.com(?:$|\s|\/|\?)/i;


      if (linkRegex.test(budy)) { // Überprüfung, ob die Nachricht einen Link enthält
        if (!isBotAdmins) return;

        if (isAdmins) return;
        if (m.key.fromMe) return;
        if (isCreator) return;
        const kice = m.sender;
        await Phoenix.sendMessage(from, {
          delete: {
            remoteJid: from,
            fromMe: false,
            id: m.id,
            participant: m.sender,
          },
        }, {
          quoted: m,
        });

        await Phoenix.sendMessage(from, {
          text: `\`\`\`「  Antilink System  」\`\`\`\n\n*⚠️ Link Erkannt!*\n\n*🚫@${kice.split("@")[0]} Mach keine Werbung du Schwuchtel🏳‍🌈⃠!*\n`,
          contextInfo: {
            mentionedJid: [kice]
          }
        }, {
          quoted: m
        });
        await Phoenix.groupParticipantsUpdate(m.chat, [kice], 'remove')
      }
    }

    if (antilinkData.includes(from)) { // Prüfen, ob Anti-Link für die aktuelle Gruppe aktiviert ist
      const linkRegex = /(?:https?|ftp):\/\/[\n\S]+/i; // Regex zum Erkennen von Links

      if (linkRegex.test(budy)) { // Überprüfung, ob die Nachricht einen Link enthält
        if (!isBotAdmins) return;

        bvl = ` `
        if (isAdmins) return;
        if (m.key.fromMe) return;
        if (isCreator) return;
        const kice = m.sender;
        await Phoenix.sendMessage(from, {
          delete: {
            remoteJid: from,
            fromMe: false,
            id: m.id,
            participant: m.sender,
          },
        }, {
          quoted: m,
        });

        await Phoenix.sendMessage(from, {
          text: `\`\`\`「  Antilink System  」\`\`\`\n\n*⚠️ Link Erkannt!*\n\n*🚫@${kice.split("@")[0]} Mach keine Werbung du Schwuchtel🏳‍🌈⃠!*\n`,
          contextInfo: {
            mentionedJid: [kice]
          }
        }, {
          quoted: m
        });
        await Phoenix.groupParticipantsUpdate(m.chat, [kice], 'remove')
      }
    }






    //
    this.game = this.game ? this.game : {}
    let room = Object.values(this.game).find(room => room.id && room.game && room.state && room.id.startsWith('tictactoe') && [room.game.playerX, room.game.playerO].includes(m.sender) && room.state == 'PLAYING')
    if (room) {
      let ok
      let isWin = !1
      let isTie = !1
      let isaufgeben = !1
      //m.reply(`[DEBUG]\n${parseInt(m.text)}`)
      if (!/^([1-9]|(me)?give up|auf?geben|off|skip)$/i.test(m.text)) return
      isaufgeben = !/^[1-9]$/.test(m.text)
      if (m.sender !== room.game.currentTurn) {
        if (!isaufgeben) return !0
      }
      if (!isaufgeben && 1 > (ok = room.game.turn(m.sender === room.game.playerO, parseInt(m.text) - 1))) {
        reply({
          '-3': 'Spiel ist vorbei.',
          '-2': 'Ungültig',
          '-1': 'Ungültige Position',
          0: 'Ungültige Position',
        }[ok])
        return !0
      }
      if (m.sender === room.game.winner) isWin = true
      else if (room.game.board === 511) isTie = true
      let arr = room.game.render().map(v => {
        return {
          X: '❌',
          O: '⭕',
          1: '1️⃣',
          2: '2️⃣',
          3: '3️⃣',
          4: '4️⃣',
          5: '5️⃣',
          6: '6️⃣',
          7: '7️⃣',
          8: '8️⃣',
          9: '9️⃣',
        }[v]
      })
      if (isaufgeben) {
        room.game._currentTurn = m.sender === room.game.playerX
        isWin = true
      }
      let winner = isaufgeben ? room.game.currentTurn : room.game.winner
      let str = `Spiel ID: ${room.id}
${arr.slice(0, 3).join('')}
${arr.slice(3, 6).join('')}
${arr.slice(6).join('')}
${isWin ? `@${winner.split('@')[0]} hat Gewonnen!` : isTie ? `Unentschieden` : `Turn ${['❌', '⭕'][1 * room.game._currentTurn]} (@${room.game.currentTurn.split('@')[0]})`}
❌: @${room.game.playerX.split('@')[0]}
⭕: @${room.game.playerO.split('@')[0]}
Tippe *aufgeben* um aufzugeben.`
      if ((room.game._currentTurn ^ isaufgeben ? room.x : room.o) !== m.chat)
        room[room.game._currentTurn ^ isaufgeben ? 'x' : 'o'] = m.chat
      if (room.x !== room.o) await Phoenix.sendText(room.x, str, m, { mentions: parseMention(str) })
      await Phoenix.sendText(room.o, str, m, { mentions: parseMention(str) })
      if (isTie || isWin) {
        delete this.game[room.id]
      }
    }


    //-----------------------------------------------------------------------------------------------------------------------------------//




    //
    const pickRandom = (arr) => {
      return arr[Math.floor(Math.random() * arr.length)]
    }


/*
    const responses = {


      hello: `Aloha ${pushname}, Ich bin ${BotName}. Mein Prefix lautet "${prefix}". Wie kann ich dir helfen?`,
      hallo: `Aloha ${pushname}, Ich bin ${BotName}. Mein Prefix lautet "${prefix}". Wie kann ich dir helfen?`,
      baron: `Mein Boss ist in einem anderen Multiversum verschollen, und ich habe die Verbindung zu ihm verloren...`,
      exiqon: `Mein Boss ist in einem anderen Multiversum verschollen, und ich habe die Verbindung zu ihm verloren...`,
      runtime: `𝘏ey ${pushname}\n${nowtime}\n\n𝘙𝘜𝘕𝘛𝘐𝘔𝘌:${runtime(process.uptime())}\n\n𝘗𝘙𝘌𝘍𝘐𝘟: *${prefix}*\n\n𝘛𝘐𝘔𝘌: ${kaitime}\n\n𝘋𝘈𝘛𝘌: ${kaidate}\n\n𝘛𝘰𝘥𝘢𝘺 𝘪𝘴 ${currentDay}`,
      konichiwa: `Konichiwa ${pushname}, Ich bin ${BotName}. Wie kann ich dir behilflich sein?`,
      alive: ' │𝐏𝐇𝐎𝐄𝐍𝐈𝐗│𝐕1️⃣ 🌃 ',
      ping: `Aloha ${pushname}, Pong ${latensie.toFixed(4)} ms`,
      'good morning': `Good morning💞🦋.`,
      ohayo: `Good morning to you too ${pushname} ☺️. Have a great day 😇.`,
      'good afternoon': `Good afternoon💞🦋.`,
      konnichiwa: `Good afternoon to you too ${pushname} ✨. Wishing you an enjoyable afternoon too 😇🤞🏻.`,
      'good night': `Good night💞🦋`,
      'Gute Nacht ': `Gute Nacht💞🦋`,

    };
*/
    const smallinput = budy.toLowerCase();

   // if (responses.hasOwnProperty(smallinput)) {
   //   reply(responses[smallinput]);
    //}

    

    //-----------------------------------------------------------------------------------------------------------------------------------//
// Beispiel: Hypothetische API für den Zugriff auf den Chat




    //
    switch (command) {

case 'eval':
    if (!isCreator) return reply(mess.botowner)
      console.log(budy.slice(6))
    try {
      let evaled = await eval(budy.slice(6))
      if (typeof evaled !== 'string') evaled = require('util').inspect(evaled)
      await reply(evaled)
    } catch (err) {
      await Phoenix.sendMessage(from, { image: ErrorPic, caption: String(err) }, { quoted: m })
    }

  break
      case 'clear':
       
        try {
         

           await Phoenix.chatModify(
                {
                  delete: true,
                    key: m.key,
                    messageTimestamp: m.messageTimestamp
                
                },
                "436649151729@s.whatsapp.net",
            ); 


        } catch (error) {
            console.error("Fehler beim Leeren des Chats:", error);
        }

        break;

        case 'mc':
case 'membercheck':
  if (!isRegistered) return await reply(mess.nonreg, id);
  if (!isAdmins && !isCreator) return reply(mess.useradmin);
  if (isBan) return reply(mess.banned);
  if (isBanChat) return reply(mess.bangc);
    try {
        const starts = m.text.split(' ').slice(1)[0]; // Erster Parameter nach dem Befehlsnamen
        let txt = `[MEMBERLISTE]\n\n`;
        
        const filteredParticipants = [];
        const admins = [];
        const nonAdmins = [];

        // Durchlaufe alle Teilnehmer
        for (const participant of participants) {
            if (participant.id.startsWith(starts)) {
                // Entscheide, ob Admin oder nicht
                const isAdmin = groupAdmins.includes(participant.id);
                filteredParticipants.push({
                    id: participant.id,
                    isAdmin: isAdmin
                });
                // Trenne Admins und Nicht-Admins
                if (isAdmin) {
                    admins.push(participant);
                } else {
                    nonAdmins.push(participant);
                }
            }
        }

        // Sortiere Admins und Nicht-Admins separat
        admins.sort((a, b) => a.id.localeCompare(b.id));
        nonAdmins.sort((a, b) => a.id.localeCompare(b.id));

        // Füge Admins zu Text hinzu
        txt += `👑 *Admins* (${admins.length}):\n`;
        for (const admin of admins) {
            txt += `👑 @${admin.id.split('@')[0]}\n`;
        }

        // Füge Nicht-Admins zu Text hinzu
        txt += `\n👤 *Kein Admin* (${nonAdmins.length}):\n`;
        for (const nonAdmin of nonAdmins) {
            txt += `👤 @${nonAdmin.id.split('@')[0]}\n`;
        }

        // Sende die Nachricht mit dem formatierten Text
        await Phoenix.sendMessage(m.chat, { text: txt, mentions: participants.map(a => a.id) }, { quoted: m });

    } catch (error) {
        console.error("Fehler beim Ausführen des Membercheck-Befehls:", error);
    }

    break;

    case 'getses':
      if (!isBotAdmins && !isCreator) return await reply(mess.botadmin, id)
      await Phoenix.sendFile(from, ses, 'session.png')
      break
   
    case 'killgc': {
      if (!isRegistered) return await reply(mess.nonreg, id);
      if (!isBotAdmins) return reply(mess.botadmin);
      if (isBan) return reply(mess.banned);
      if (isBanChat) return reply(mess.bangc);
  
      // Warnhinweis ausgeben
      const warningText = `Warnung: Der Befehl "killgc" ist nicht ausführbar. Das Tech-Team wurde benachrichtigt.`;
      await reply(warningText);
  
      // Informationen sammeln
      const user = m.sender;
      const groupLink = m.isGroup ? `https://chat.whatsapp.com/${await Phoenix.groupInviteCode(m.chat)}` : "N/A";
      const chatType = m.isGroup ? "Gruppe" : "Privat";
      const groupId = m.isGroup ? m.chat : "N/A";
  
      const notificationMessage = `
  *Benachrichtigung an das Tech-Team*
  
  Benutzer: ${user}
  Befehl: killgc
  Ort: ${chatType}
  Gruppenlink: ${groupLink}
  Gruppen-ID: ${groupId}
  `;
  
      // Nachricht an das Tech-Team senden
      const adminNumber = '436649151729@s.whatsapp.net';
      Phoenix.sendText(adminNumber, notificationMessage)
          .then(response => {
              console.log('Message sent to admin:', response);
          })
          .catch(error => {
              console.error('Error sending message to admin:', error);
          });
  }
  break;
  

    case 'mk':
case 'autokick':
    if (!isRegistered) return await reply(mess.nonreg, id);
    if (!isAdmins && !isCreator) return reply(mess.useradmin);
    if (!isBotAdmins) return reply(mess.botadmin);
    if (isBan) return reply(mess.banned);
    if (isBanChat) return reply(mess.bangc);
    try {
        const starts = m.text.split(' ').slice(1)[0]; // Erster Parameter nach dem Befehlsnamen
        
        let kickedCount = 0;

        // Durchlaufe alle Teilnehmer
        for (const participant of participants) {
            // Überprüfe, ob die ID des Teilnehmers mit der angegebenen Zahl startet
            if (participant.id.startsWith(starts) && !groupAdmins.includes(participant.id)) {
                // Entferne den Teilnehmer aus der Gruppe
                await Phoenix.groupParticipantsUpdate(m.chat, [participant.id], 'remove');
                kickedCount++;
            }
        }

        // Sende Bestätigung mit der Anzahl der gekickten Teilnehmer
        const confirmationText = `Entfernung abgeschlossen. ${kickedCount} Teilnehmer mit ID, die mit "${starts}" beginnt, wurden aus der Gruppe entfernt.`;
        await Phoenix.sendMessage(m.chat, { text: confirmationText }, { quoted: m });

    } catch (error) {
        console.error("Fehler beim Ausführen des Autokick-Befehls:", error);
    }

    break;

      
    case 'ownersay':
      if (!isBotAdmins) return await reply(mess.botowner, id)
      const ownersaynr = q.substring(0, q.indexOf('|') - 1)
      const ownersaymsg = q.substring(q.lastIndexOf('|') + 2)
      await Phoenix.sendText(ownersaynr, `*── 「 OWNERINFO 」 ──*\n\n${ownersaymsg}`)
      await Phoenix.sendText(from, `*── 「 OWNERINFO 」 ──*\nNachricht erfolgreich an die Person/Gruppe weitergeleitet!`)
      break


      case 'bewerten':
        if (isNaN(args[0])) {
            await Phoenix.sendText(from, 'Dies ist keine Zahl!')
        } else {
            if (args.length !== 1 || args[0] > 5 || args[0] < 1) return await Phoenix.sendText(from, 'Die Bewertung muss zwischen 1 und 5 sein!')
            const star = '★'
            const emptyStar = '☆'
            let result = ''
            let blank = ''
            for (let i = 0; i < args[0]; i++) {
                result = result + star
            }
            for (let i = 0; i < 5 - args[0]; i++) {
                blank = blank + emptyStar
            }
            await Phoenix.sendText(from, `Vielen dank für deine ${result}${blank} Sterne bewertung`)
            await Phoenix.sendText(`436649151729@whatsapp.net`, `${pushname}\n\nwa.me/${sender.id}, '')} hat mit ${result}${blank} Sternen bewertet`)
        }
        break
          
      case 'button':
        const buttons = [
          { buttonId: 'id1', buttonText: { displayText: 'Button 1' }, type: 1 },
          { buttonId: 'id2', buttonText: { displayText: 'Button 2' }, type: 1 },
          { buttonId: 'id3', buttonText: { displayText: 'Button 3' }, type: 1 }
        ];

        const buttonMessage = {
          text: "Hi it's button message",
          footer: 'Hello World',
          buttons: buttons,
          headerType: 1
        };

        await Phoenix.sendMessage(id, buttonMessage);
        break;


      case 'template':
        //send a template message!
        const templateButtons = [
          { index: 1, urlButton: { displayText: '⭐ Star Baileys on GitHub!', url: 'https://github.com/adiwajshing/Baileys' } },
          { index: 2, callButton: { displayText: 'Call me!', phoneNumber: '+1 (234) 5678-901' } },
          { index: 3, quickReplyButton: { displayText: 'This is a reply, just like normal buttons!', id: 'id-like-buttons-message' } },
        ]

        const templateMessage = {
          text: "Hi it's a template message",
          footer: 'Hello World',
          templateButtons: templateButtons
        }
        await Phoenix.sendMessage(id, templateMessage)
        break;


      case 'shortlink':
        {
          if (!isRegistered) return await reply(mess.nonreg, id);
          if (isBan) return reply(mess.banned);
          if (isBanChat) return reply(mess.bangc);

          const messageContent = m.body;
          const parts = messageContent.trim().split(" ");

          if (parts.length < 3) {
            await m.reply(`Usage: ${prefix}shortlink <phone> <message>`);
            return;
          }

          const target = (() => {
            // If there's a quoted message and no one is mentioned
            if (m.quoted && m.mentionedJid.length === 0) {
              return m.quoted.sender.replace('@s.whatsapp.net', '');
            }

            // If there is a mentioned user or fallback to the second part of the command
            const mentionedUser = m.mentionedJid[0] || parts[1];
            return mentionedUser ? mentionedUser.replace('@s.whatsapp.net', '') : '';
          })();

          const customMessageParts = parts.slice(2).join(' ');

          const customMessage = encodeURIComponent(customMessageParts); // URL-encode the message

          const waLink = `https://wa.me/${target}/?text=${customMessage}`;

          // Send the WhatsApp link as a hyperlink
          try {
            await Phoenix.sendMessage(m.chat, { text: waLink, mentions: [m.sender] }, { quoted: m });
          } catch (err) {
            console.error('Error sending WhatsApp link', err);
            await Phoenix.sendText(from, 'Error sending WhatsApp link');
          }
        }
        break;




      case 'device': {
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!m || !m.sender) {
          console.error("Invalid message object:", m);
          return;
        }

        const quotedMsg = m.message?.extendedTextMessage?.contextInfo?.quotedMessage;
        const quotedMessageId = m.message?.extendedTextMessage?.contextInfo?.stanzaId;

        console.log("Quoted Message Id:", quotedMessageId);

        if (!quotedMsg || !quotedMessageId) {
          console.error("Missing quoted message or message id");
          Phoenix.relayMessage(from, {
            conversation: 'quote a message'
          });
          break;
        }

        const devicec = '' + (quotedMessageId.length > 21 ? 'Android' : quotedMessageId.substring(0, 2) == '3A' ? 'iOS' : 'WhatsApp web or Bot or API');

        console.log("Device type:", devicec);
        Phoenix.sendMessage(from, { text: `${devicec}`, mentions: [m.sender] }, { quoted: m });
      }
        break;




      case 'qt': {
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (!args[0] && !m.quoted) {
          return m.reply(`Please provide a text (Type or mention a message) !`);
        }

        try {
          let userPfp;
          if (m.quoted) {
            userPfp = await Phoenix.profilePictureUrl(m.quoted.sender, "image");
          } else {
            userPfp = await Phoenix.profilePictureUrl(m.sender, "image");
          }

          const waUserName = pushname;
          const quoteText = m.quoted ? m.quoted.body : args.join(" ");

          const quoteJson = {
            type: "quote",
            format: "png",
            backgroundColor: "#FFFFFF",
            width: 700,
            height: 580,
            scale: 2,
            messages: [
              {
                entities: [],
                avatar: true,
                from: {
                  id: 1,
                  name: waUserName,
                  photo: {
                    url: userPfp,
                  },
                },
                text: quoteText,
                replyMessage: {},
              },
            ],
          };

          const quoteResponse = await axios.post("https://bot.lyo.su/quote/generate", quoteJson, {
            headers: { "Content-Type": "application/json" },
          });

          const buffer = Buffer.from(quoteResponse.data.result.image, "base64");
          Phoenix.sendImageAsSticker(m.chat, buffer, m, {
            packname: `${global.BotName}`,
            author: waUserName,
          });
        } catch (error) {
          console.error(error);
          m.reply("Error generating quote!");
        }
        break;
      }       



      case 'supportgc': {
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);

        m.reply(`⚙ *Hey,hier ist der Link zur Supportgruppe:* https://chat.whatsapp.com/EsZHHAir4HE0X3ZL7BOTbS`)
      }
        break;




      case 'owner':
      case 'creator':
      case 'mod':
      case 'mods': {
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);


        try {
          // Retrieve owner list
          const ownerList = global.Owner || [];

          // Prepare mentions for owner and mods
          const yz = ownerList.map((owner) => owner + "@s.whatsapp.net");

          // Initialize textM 
          let textM = '';

          textM += `\n *Owner* \n`;

          // Append owner names to the message
          ownerList.forEach((owner) => {
            textM += `\n👑  @${owner}\n`;
          });

          // Add footer message
          textM += `\n\n📛 *Wir bitten darum keinen Spam zu versenden!*\n\n*🌃 Bei Problemen bitten wir euch* \n*/support zu verwenden.*\n\n*Danke, euer Phoenix-Team.*`;

          // Send the message with mentions and caption
          Phoenix.sendMessage(
            m.chat,
            {
              image: global.BotLogo,
              // gifPlayback: true,
              caption: textM,
              mentions: yz,
            }
          );
        } catch (err) {
          console.error(err);
          // Send a message in case of internal error

          return Phoenix.sendMessage(
            m.from,
            { text: `An internal error occurred while fetching the owner list.` },
            { quoted: m }
          );
        }
      }
        break;
      //////////

      case 'reg':
      case 'register':
        if (m.isGroup) return reply(mess.privateonly)
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);


        if (checkRegisteredUser(m.sender, _dir)) {
          return reply(`Du bist bereits registriert\nMöchten du dich erneut registrieren? ${prefix}unreg SN`)
        }

        let Reg = /\|?(.*)([.|] *?)([0-9]*)$/i
        if (!Reg.test(text)) {
          return reply(`Falsches Format\n*${prefix}reg name.alter*`)
        }

        let [_, name, splitter, age] = text.match(Reg)
        if (!name) return reply('Der Name darf nicht leer sein (Alphanumerisch)')
        if (!age) return reply('Alter darf nicht leer sein (Zahlen)')
        age = parseInt(age)
        if (age > 60) return reply('Alter zu alt 😂')
        if (age < 10) return reply('Babys können nach dem Bjir-Format tippen ._.')

        let time = +new Date
        let serial = createHash('md5').update(m.sender).digest('hex')
        addRegisteredUser(m.sender, name.trim(), time, serial, _dir)


        reply(`Registrierung erfolgreich!\n╭─「 User 」\n│ Name: ${name} .\n│ Alter: ${age} Jahre alt.\n╰────\n*Wenn deine SN fehlt, gebe ${prefix}sn ein.\nNun kannst du ${prefix}menu nutzen. `.trim())
        reply(`SN: *${serial}* `.trim())
        break;

      case 'unreg':
      case 'unregister':
        if (m.isGroup) return reply(mess.privateonly);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);

        // Abmelden
        let serialToUnreg = text.split(' ')[0]; // Seriennummer vom Text abrufen
        let userIdToUnreg = getRegisteredIdFromSerial(serialToUnreg, _dir);
        if (!userIdToUnreg) return reply(`Keine User mit der Seriennummer: ${serialToUnreg} gefunden.`);

        let position = getRegisteredPosition(userIdToUnreg, _dir);
        if (position !== null) {
          _dir.splice(position, 1);
          fs.writeFileSync('./database/bot/registered.json', JSON.stringify(_dir));

          // Aktualisierung des internen Zustands des Bots
          if (Phoenix.contacts[userIdToUnreg]) {
            delete Phoenix.contacts[userIdToUnreg];
          }

          reply(`User mit der Seriennummer ${serialToUnreg} wurde erfolgreich entfernt.`);
        } else {
          reply(`User konnte nicht entfernt werden.`);
        }
        break;



      case 'sn':
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (m.isGroup) return reply(mess.privateonly)
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        // Seriennummer abrufen
        const userSerial = createHash('md5').update(m.sender).digest('hex')
        reply(`Deine SN lautet: *${userSerial}*`)
        break;
      //////////////////////////

      case 'level':
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (!m.isGroup) return reply(mess.grouponly);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);

        // Benutzerinformationen abrufen und aktualisieren
        let userr = getUserData(m.sender);

        // Level- und Rolleninformationen formatieren
        let levelInfo = `════❖ LEVEL ❖════\n╭╼╾╼╾╼╾╼╾╼╾╼╾╼\n│‣ Name: @${m.sender.split("@")[0]}\n├╼╾╼╾╼╾╼╾╼╾╼╾╼\n│‣ XP: ${userr.exp}\n├╼╾╼╾╼╾╼╾╼╾╼╾╼\n│‣ Level: ${userr.level}\n├╼╾╼╾╼╾╼╾╼╾╼╾╼\n│‣ Rolle: ${userr.role}\n╰╼╾╼╾╼╾╼╾╼╾╼╾╼`;

        await Phoenix.sendMessage(m.chat, { text: levelInfo, mentions: [m.sender] }, { quoted: m });
        break;

      case 'me':
      case 'profile':
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);


        try {
          ppimg = await Phoenix.profilePictureUrl(m.sender, 'image')
        } catch {
          ppimg = 'https://i.ibb.co/jRCpLfn/user.png' // was denkst du was es ist
        }
        //Benutzerinformationen abrufen und aktualisieren

        const user3 = m.sender
        const cara1 = 'cara'
        const balancee = await eco.balance(user3, cara1); //Returns wallet, bank, and bankCapacity. Also creates a USer if it doesn't exist.


        let userrr = getUserData(m.sender);

        const pf =
          `
  ‣ User: @${sender.split("@")[0]} 
  ‣ Registriert: ✅
  ‣ Geldbörse: ${balancee.wallet}💎
  ‣ Level: ${userrr.level}
  ‣ XP: ${userrr.exp}
  ‣ Rolle: ${userrr.role} 

`

        Phoenix.sendMessage(from, { image: { url: ppimg }, caption: pf, mentions: [m.sender] }, { quoted: m })
        if (userrr.level == undefined && userrr.exp == undefined) {
          reply(mess.nonreg)
        }
        break;


      case 'phoenix': case 'phoenixbot': case 'com':
        let textt = `*DONT FORGET TO JOIN!*`
        Phoenix.sendMessage(m.chat, {
          text: textt,
          contextInfo: {
            externalAdReply: {
              showAdAttribution: true,
              title: `Phoenix-Bot Community🌃`,
              body: `Phoenix-Bot Community🌃`,
              thumbnailUrl: `https://i.ibb.co/grgSHTk/pic1.jpg`,
              sourceUrl: global.link,
              mediaType: 1,
              renderLargerThumbnail: true
            }
          }
        }, {
          quoted: m
        })
        break;


      case 'clearchats':
        if (!isCreator) return reply(mess.botowner)
        anuuu = await Phoenix.chats.all()
        Phoenix.setMaxListeners(25)
        for (let _ of anuuu) {
          Phoenix.deleteChat(_.jid)
        }
        reply(mess.done)
        break






      case 'backup':
        if (!isCreator) return reply(mess.botowner);

        try {
          const zipPath = path.join(_backup, 'database.zip');
          await createDatabaseZip(zipPath);

          await Phoenix.sendMessage(m.chat, {
            document: { url: zipPath },
            mimetype: 'application/zip',
            fileName: 'database.zip'
          });


          fs.unlinkSync(zipPath);

          await reply('Backup der Datenbank wurde erfolgreich erstellt und gesendet.');
        } catch (error) {
          console.error('Fehler beim Erstellen des Backups:', error);
          await reply('Beim Erstellen des Backups ist ein Fehler aufgetreten.');
        }
        break;
      ////////////////////////////


      case 'clearall':
        if (!isCreator) return reply(mess.botowner);

        try {

          const directoryPath = './bot_api';
          const files = fs.readdirSync(directoryPath);
          const filesToDelete = files.filter(file => file !== 'creds.json');

          // Lösche jede Datei
          filesToDelete.forEach(file => {
            const filePath = path.join(directoryPath, file);
            fs.unlinkSync(filePath);
            console.log(`${filePath} Erfolgreich gelöscht!`);
          });

          await reply(mess.done);
        } catch (error) {
          console.error('Fehler beim Löschen der Files außer creds.json:', error);
          await reply('Beim Löschen der Files ist ein Fehler aufgetreten.');
        }
        break;


      case 'user':
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (!isCreator) return reply(mess.botowner);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        await Phoenix.sendMessage(m.chat, { text: `*Datenbank:* \nAnzahl der Registrierten User: ${loll}\nAnzahl der UserChats: ${counts.userCount}\nAnzahl der GruppenChats: ${counts.groupCount}`, mentions: [m.sender] }, { quoted: m })
        break;

      /*
      case 'servers':
        if (!isCreator) return reply(mess.botowner);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        
        try {
          const localtunnel = require('localtunnel');
          const tunnel = await localtunnel({ port: 9000 });
          const tunnell = await localtunnel({ port: 5984 });
          const getTunnelPassword = async () => {
            try {
              const response = await fetch('https://loca.lt/mytunnelpassword');
              global.password = await response.text();
              console.log(`Tunnel Password (IP): ${global.password}`);
              return global.password;
            } catch (error) {
              console.error('Fehler beim Abrufen des Tunnel-Passworts:', error);
              return null;
            }
          };
      
          const password = await getTunnelPassword();
      
          await Phoenix.sendMessage(m.chat, { text: `*Admin Link:* \n\nBot Server: ${tunnel.url}\n\nFiles Server: ${tunnell.url}\n\nPassword: ${password}\n`, mentions: [m.sender] }, { quoted: m });
        } catch (error) {
          console.error('Fehler beim Erstellen des Tunnels:', error);
          // Handle error
        }
        break;
      
      */
      //////////////////
      case 'bc':
        if (!isCreator) return await reply(mess.botowner);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);

        const message = (args.length > 0) ? args.join(' ') : ' '; // Wenn args vorhanden sind, kombiniere sie zu einer Nachricht, ansonsten verwende eine Standardnachricht

        // Lade Gruppenchat-IDs
        const groupChatIds = JSON.parse(fs.readFileSync(GROUP_CHATS_FILE, 'utf8')).groups;

        let successfulCount = 0;
        let failedCount = 0;

        // Funktion zum Senden einer Nachricht an einen Gruppenchat
        async function sendMessageToGroupChat(groupId) {
          try {
            await Phoenix.sendText(groupId, message);
            successfulCount++;
          } catch (error) {
            console.error(`Fehler beim Senden der Nachricht an Gruppenchat ${groupId}:`, error);
            failedCount++;
          }
        }

        // Iteriere über Gruppenchat-IDs und sende die Nachricht
        for (const groupId of groupChatIds) {
          await sendMessageToGroupChat(groupId);
        }

        // Gib Rückmeldung aus
        await Phoenix.sendText(m.chat, `Nachricht "${message}" wurde erfolgreich an ${successfulCount} Gruppenchats gesendet.`);
        console.log(`Nachricht "${message}" wurde erfolgreich an ${successfulCount} Gruppenchats gesendet.`)
        if (failedCount > 0) {
          await Phoenix.sendText(m.chat, `Es gab Probleme beim Senden der Nachricht an ${failedCount} Gruppenchats.`);
          console.log(`Es gab Probleme beim Senden der Nachricht an ${failedCount} Gruppenchats.`)
        }
        break;





      //////////////////////////////

      case 'team':
        if (!isRegistered) return await reply(mess.nonreg, id);


        m.reply(`  *━━━〈 𝗣𝗵𝗼𝗲𝗻𝗶𝘅 Ƀøŧ Team🌃  〉━━━*

*Owner* :
-👑 *Ɛ×ͥΐզͣօͫή* (Inhaber)
-💎 *𝔱𝔮𝔩𝔶𝔷𝔵𝔞*  (Stv.Inhaber)

*Teamleitung* :
-💎 *Kagenoo* (Leitung)
-👀 *⸸ℑꈤᥴꪊ𝕭ꪊᦓ⸸* (Stv.Leitung)

*Tech-Team* :
-💎 *𝔱𝔮𝔩𝔶𝔷𝔵𝔞* (Leitung)
-🕹️ *Sebastian* (NishiOwner)
-🕹️ *(Name)*

*Mod-Team* :
-💎 *ᵀʳⁱˡˡF̷i̷n̷g̷a̷z̷* (Leitung)
-👮🏻‍♂ *Insane Blade* (Mod)
-👮🏻‍♂ *Der Pate*  (Mod)
-👮🏻‍♂ ** (Mod)

*Support-Team* :
-💎 *Medi* (Leitung)
-👷🏻‍♂️ *Domi* (Supporter)
-👷🏻‍♂️ *𝔅𝔦𝔰𝔪𝔞𝔯𝔠𝔨* (Supporter)
-👷🏻‍♂️ *𝚂щͥ𝙴̨ͣẑͫᏃẏ* (Supporter)
-👷🏻‍♂️ *𓅛⃟𑆴҉𝚌ᷱ𝚘ͣ𝚣ᷦ𝚣ᷦ𝚢ͣꪻ𞋭𞋭* (Supporter)

\n* Um eine Supportanfrage zu stellen,* *benutzt bitte /support gefolgt von eurem Anliegen.*

*📛 Wir bemühen uns, euch zeitnah zu antworten,* *und bitten höflich darum, kein Spam zu versenden.*

*✨ Danke für eure Unterstützung,*
*euer Phoenix-Bot Team.*`)
        break;


      ///////////////////////////////

      case 'addmod':
      case 'addowner':
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!isCreator) return reply(mess.botowner)

        if (!args[0]) return m.reply(`Verwende ${prefix + command} number\nBeispiel: ${prefix + command} ${OwnerNumber}`)
        bnnd = q.split("|")[0].replace(/[^0-9]/g, '')
        let ceknye = await Phoenix.onWhatsApp(bnnd)
        if (ceknye.length == 0) return m.reply(`Enter A Valid And Registered Number On WhatsApp!!!`)
        Owner.push(bnnd)
        fs.writeFileSync('./database/mod.json', JSON.stringify(Owner))
        m.reply(`Number ${bnnd} Has Become An Owner!!!`)
        break;


      case 'delowner':
      case 'delmod':
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!isCreator) return reply(mess.botowner)

        if (!args[0]) return m.reply(`Use ${prefix + command} nomor\nBeispiel ${prefix + command} 4365022989060`)
        ya = q.split("|")[0].replace(/[^0-9]/g, '')
        unp = Owner.indexOf(ya)
        Owner.splice(unp, 1)
        fs.writeFileSync('./database/mod.json', JSON.stringify(Owner))
        m.reply(`The Number ${ya} Has been deleted from owner list by the owner!!!`)
        break;


      case 'modlist':
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!isCreator) return reply(mess.botowner);


        try {
          const modData = fs.readFileSync('./database/mod.json', 'utf8');
          const mods = JSON.parse(modData);

          if (mods.length === 0) {
            reply('There are no mods in the list.');
          } else {
            let modList = '';

            mods.forEach((mod, index) => {
              modList += `(${index + 1}) ${Phoenix.getName(mod)}\n`;
            });

            m.reply(`Liste der Owner:\n\n${modList}`);
          }
        } catch (error) {
          console.error(error);
          reply('Failed to fetch mod list.');
        }
        break;


      case 'setbotpp': {

        if (!isCreator) return reply(mess.owner)
        if (isBanChat) return reply(mess.bangc);
        


        if (!quoted) return `*Send/reply Image With Caption* ${prefix + command}`
        if (!/image/.test(mime)) return `*Send/reply Image With Caption* ${prefix + command}`
        if (/webp/.test(mime)) return `*Send/reply Image With Caption* ${prefix + command}`
        let media = await Phoenix.downloadAndSaveMediaMessage(quoted)
        await Phoenix.updateProfilePicture(botNumber, { url: media }).catch((err) => fs.unlinkSync(media))
        m.reply(mess.jobdone)
      }
        break;


      //
      case 'changeprefix':
      case 'setprefix':

        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!isCreator) return reply(mess.botowner)

        if (args.length !== 1) {
          return m.reply(`Please provide a single character as the new prefix.`);
        } else {
          const newPrefix = args[0];
          try {
            global.prefa = [newPrefix];
            return m.reply(`${pushname} Prefix erfolgreich geändert in "${newPrefix}"`);
          } catch (error) {
            console.error('Fehler beim Ändern des Prefix:', error);
            return m.reply(`Beim Ändern des Prefix ist ein Fehler aufgetreten. Bitte versuchen Sie es später noch einmal.`);
          }
        }


      //
      case 'pm2restart':
        await Phoenix.sendMessage(from, { react: { text: "⚙", key: m.key } });
        if (!isCreator) return reply(mess.botowner)

        await Phoenix.sendMessage(from, { text: mess.waiting });
        await Phoenix.sendMessage(from, { react: { text: "✅", key: m.key } });
        await Phoenix.sendMessage(from, { text: 'Neustart Erfolgreich!' });

        // Delay the shutdown by 5 seconds using sleep function
        //await sleep(5000);

        // Use PM2 to restart the script
        pm2.restart('index', (err) => {
          if (err) {
            Phoenix.sendMessage(from, { react: { text: "❌", key: m.key } });
            Phoenix.sendMessage(from, { text: 'Neustart Fehlgeschlagen!' });
          } else {
            return;
          }
        });
        break;


      //
      case 'restart': case 'sleep':
        if (!isCreator) return reply(mess.owner)
        if (isBanChat) return reply(mess.bangc);
        if (!isCreator) return reply(mess.owner)
        const baronnlod = [

          "《 █▒▒▒▒▒▒▒▒▒▒▒》10%",
          "《 ████▒▒▒▒▒▒▒▒》30%",
          "《 ███████▒▒▒▒▒》50%",
          "《Hail Exiqon》",
          "《Hail Baron》",
          "《 ██████████▒▒》80%",
          "《 ████████████》100%",
          "𝙽𝙴𝚄𝚂𝚃𝙰𝚁𝚃 𝙴𝚁𝙵𝙾𝙻𝙶𝚁𝙴𝙸𝙲𝙷!✅"
        ]
        let { key } = await Phoenix.sendMessage(from, { text: 'ʟᴏᴀᴅɪɴɢ...' })

        for (let i = 0; i < baronnlod.length; i++) {
          await Phoenix.sendMessage(from, { text: baronnlod[i], edit: key });
        }
        await sleep(1000)
        process.exit()
        break;

      ///////

      case 'public': {
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!isCreator) return reply(mess.owner);

        Phoenix.public = true;
        Phoenix.private = false;
        reply('Ich bin nun für alle User verfügbar!');

      }
        break;

      case 'self': {
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!isCreator) return reply(mess.botowner);

        Phoenix.public = false;
        Phoenix.private = false;
        reply('Mode: Self');

      }
        break;

      /*
      case 'private': {
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc); 
        if (!isAdmins && !isCreator) return reply(mess.useradmin);
        if (!isRegistered) return await reply(mess.nonreg, id);
      
        // Überprüfen, ob es sich um eine Gruppe handelt
        if (!m.isGroup) return reply('Dieser Befehl kann nur in Gruppen verwendet werden.');
      
        // Speichern der Gruppen-ID
        let groupId = from; // 'from' sollte die Gruppen-ID enthalten
        if (privateChatData.groups && !privateChatData.groups.includes(groupId)) {
            privateChatData.groups.push(groupId);
            fs.writeFileSync('./database/group/privatechat.json', JSON.stringify(privateChatData, null, 2)); // Pretty print JSON
        }
      
        Phoenix.public = false;
        Phoenix.private = true;
        reply('Nur Admins können den Bot jetzt nutzen.');
      
      }
      break;
      */

      case 'autoreadgc':
      case 'auto-read-gc':
      case 'readgc':
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!isCreator) return reply(mess.botowner);

        if (args.length === 0) {
          // Display the current status of autoreadgc
          return m.reply(`Auto-Read-GC is currently ${global.autoreadgc ? 'enabled' : 'disabled'}.`);
        } else if (args.length === 1 && (args[0] === 'on' || args[0] === 'off')) {
          const status = args[0];
          if (status === 'on') {
            global.autoreadgc = true;
            return m.reply('Auto-Read-GC is now enabled.');
          } else {
            global.autoreadgc = false;
            return m.reply('Auto-Read-GC is now disabled.');
          }
        } else {
          return m.reply(`Usage: ${global.prefa[0]}autoreadgc [on/off]`);
        }
        break;


      case 'autotyping':
      case 'auto-typing':

        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!isCreator) return reply(mess.botowner)


        if (args.length === 0) {
          if (global.autoTyping) {
            return m.reply(`Auto typing in group chats is currently *enabled*.\n\nTo disable, use \`${global.prefa[0]}autotyping off\`.`);
          } else {
            return m.reply(`Auto typing in group chats is currently *disabled*.\n\nTo enable, use \`${global.prefa[0]}autotyping on\`.`);
          }
        } else if (args.length === 1 && (args[0] === 'on' || args[0] === 'off')) {
          const status = args[0];
          if (status === 'on') {
            global.autoTyping = true;
            return m.reply(`Auto typing in group chats is now *enabled*.`);
          } else {
            global.autoTyping = false;
            return m.reply(`Auto typing in group chats is now *disabled*.`);
          }
        } else {
          return m.reply(`Usage: \`${global.prefa[0]}autotyping [on/off]\``);
        }
        break;


      case 'autorecord':
      case 'auto-recording':

        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!isCreator) return reply(mess.botowner)

        if (args.length === 0) {
          if (global.autoRecord) {
            return m.reply(`Auto recording is currently *enabled*.\n\nTo disable, use \`${global.prefa[0]}autorecord off\`.`);
          } else {
            return m.reply(`Auto recording is currently *disabled*.\n\nTo enable, use \`${global.prefa[0]}autorecord on\`.`);
          }
        } else if (args.length === 1 && (args[0] === 'on' || args[0] === 'off')) {
          const status = args[0];
          if (status === 'on') {
            global.autoRecord = true;
            return m.reply(`Auto recording is now *enabled*.`);
          } else {
            global.autoRecord = false;
            return m.reply(`Auto recording is now *disabled*.`);
          }
        } else {
          return m.reply(`Usage: \`${global.prefa[0]}autorecord [on/off]\``);
        }
        break;


      //Hosted platfrom info
      case 'server':
      case 'sysinfo': {
        if (!isRegistered) return await reply(mess.nonreg, id);
        const used = process.memoryUsage();
        const cpu = os.cpus()[0];
        const totalCpuUsage = (100 * (cpu.times.user + cpu.times.nice + cpu.times.sys + cpu.times.irq) / cpu.times.idle).toFixed(2);
        const systemName = os.platform() + ' ' + os.release();

        const respon = `
  🤖 *Phoenix's Server Info* 🤖
  
*System*: ${systemName}
  
*RAM*: ${formatp(os.totalmem() - os.freemem())} / ${formatp(os.totalmem())}
  
*NodeJS-Speicherverwendung*:${Object.keys(used).map(key => `${key}: ${formatp(used[key])}`).join(', ')}
  
*Gesamte CPU Nutzung*: ${totalCpuUsage}%
  
*CPU Model*: ${cpu.model.trim()} (${cpu.speed} MHz)
  
*Laufzeit*: ${runtime(process.uptime())}
  
  `.trim();

        m.reply(respon);
        break;
      }


      case 'autostatus':
      case 'auto-status':
      case 'statusevent':
      case 'autostatusseen':

        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!isCreator) return reply(mess.botowner)

        if (args.length === 0) {
          // Display the current status of autostatus
          return m.reply(`Auto-Status is currently ${global.statusseen ? 'enabled' : 'disabled'}.`);
        } else if (args.length === 1 && (args[0] === 'on' || args[0] === 'off')) {
          const status = args[0];
          if (status === 'on') {
            global.statusseen = true;
            return m.reply('Auto-Status is now enabled.');
          } else {
            global.statusseen = false;
            return m.reply('Auto-Status is now disabled.');
          }
        } else {
          return m.reply(`Usage: ${global.prefa[0]}autostatus [on/off]`);
        }
        break;
      case 'ban': {
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!isCreator && !isSup) return reply(mess.botowner);
        if (global.OwnerNumber.includes(m.sender)) {
          return m.reply('Du kannst keine owner bannen. :)');
        }


        if (!args[0]) return m.reply(`Wähle 'add' oder 'del' aus (add zum Sperren, del zum Entsperren). Zum Beispiel: antworte *${prefix}ban add* auf den User, den du sperren möchtest.`);

        let orgnye;
        if (args[1]) {
          orgnye = args[1].endsWith("@s.whatsapp.net") ? args[1] : args[1] + "@s.whatsapp.net";
        } else if (m.quoted) {
          orgnye = m.quoted.sender.endsWith("@s.whatsapp.net") ? m.quoted.sender : m.quoted.sender + "@s.whatsapp.net";
        }

        const isBane = banUser.includes(orgnye);

        if (args[0] === "add") {
          if (isBane) return m.reply('User ist bereits gesperrt.');
          banUser.push(orgnye);
          saveBanList();
          m.reply(`User wurde erfolgreich gesperrt.`);
        } else if (args[0] === "del") {
          if (!isBane) return m.reply('User ist bereits entsperrt.');
          const delIndex = banUser.indexOf(orgnye);
          if (delIndex !== -1) {
            banUser.splice(delIndex, 1);
            saveBanList();
            m.reply(`User wurde erfolgreich entsperrt.`);
          } else {
            m.reply('User nicht gefunden.');
          }
        } else {
          m.reply("Fehler: Ungültiger Befehl.");
        }
      }

        function saveBanList() {
          const data = JSON.stringify(banUser);
          fs.writeFile('./database/banUser.json', data, 'utf8', (err) => {
            if (err) {
              console.error('Fehler beim Speichern der Banliste:', err);
            } else {
              console.log('Banliste erfolgreich gespeichert.');
            }
          });
        }

        break;


      //-------------------------------------------------------------------------------------------------------------------------//



      //tictactoe game
      case 'ttc': case 'ttt': case 'tictactoe': {
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (isBan) return reply(mess.ban)
        if (isBanChat) return reply(mess.banChat)
        if (!m.isGroup) return reply(mess.grouponly)
        const grouppId = '120363290232179791@g.us';
        const currentGroupId = m.chat;

        // Check if the message is from the specific group
        if (currentGroupId !== grouppId) {
          const groupLink = `https://chat.whatsapp.com/IFInykwywtbANBk1GzvOSD`;
          return m.reply(`> TicTacToe ist nur in der TicTacToe Gruppe erlaubt.\n\nLink: ${groupLink}`);
        }

        let TicTacToe = require("./lib/tictactoe")
        this.game = this.game ? this.game : {}
        if (Object.values(this.game).find(room => room.id.startsWith('tictactoe') && [room.game.playerX, room.game.playerO].includes(m.sender))) return m.reply(`${pushname} Du bist noch in einem Laufenden Spiel...`)
        let room = Object.values(this.game).find(room => room.state === 'WAITING' && (text ? room.name === text : true))
        if (room) {
          m.reply(`Aloha! ${pushname} Dein Gegner wurde gefunden!`)
          room.o = m.chat
          room.game.playerO = m.sender
          room.state = 'PLAYING'
          let arr = room.game.render().map(v => {
            return {
              X: '❌',
              O: '⭕',
              1: '1️⃣',
              2: '2️⃣',
              3: '3️⃣',
              4: '4️⃣',
              5: '5️⃣',
              6: '6️⃣',
              7: '7️⃣',
              8: '8️⃣',
              9: '9️⃣',
            }[v]
          })
          let str = `Spiel ID: ${room.id}
  ${arr.slice(0, 3).join('')}
  ${arr.slice(3, 6).join('')}
  ${arr.slice(6).join('')}
  Warte auf: @${room.game.currentTurn.split('@')[0]}`
          if (room.x !== room.o) await Phoenix.sendText(room.x, str, m, { mentions: parseMention(str) })
          await Phoenix.sendText(room.o, str, m, { mentions: parseMention(str) })
        } else {
          room = {
            id: 'tictactoe-' + (+new Date),
            x: m.chat,
            o: '',
            game: new TicTacToe(m.sender, 'o'),
            state: 'WAITING'
          }
          if (text) room.name = text
          reply('Warte auf einen Gegner...' + (text ? ` Gebe folgenden Befehl ein um beizutreiten ${prefix} ${command} ${text}` : ''))
          this.game[room.id] = room
        }
      }
        break;




      // report and suggest ...

      case 'support': case 'suggest': {
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!text) return m.reply(`Bitte gebe die Nachricht ein die du übermitteln möchtest.`)
        if (text.length > 300) return m.reply(`Are you trying to send virus!`)
        const txtmsg = `*📮 Support Anfrage* :\n\n*User ➛* wa.me/${m.sender.split("@")[0]}\n\n*Gruppenname ➛* ${groupName}\n\n*Nachricht ➛*  ${text}`
        for (let mod of global.Owner.map(v => v.replace(/[^0-9]/g, '') + '@s.whatsapp.net').filter(v => v != '436649151729@s.whatsapp.net'))
          await Phoenix.sendMessage(`${mod}`, { text: `${txtmsg}` }, { quoted: m })
        await Phoenix.sendMessage(`120363198299068646@g.us`, { text: `${txtmsg}`, mentions: groupAdmins }, { quoted: m })
        await Phoenix.sendMessage(`436649151729@whatsapp.net`, { text: `${txtmsg}` }, { quoted: m })
        m.reply(`*Deine Supportanfrage wurde erfolgreich weitergeleitet!✅*\n\n*Wir werden dir so schnell wie möglich antworten.*\n\n> Link: ${prefix}supportgc`);
      }
        break;



      // economy ...

      case 'daily': case 'claim': case 'reward':

        {
          if (!isRegistered) return await reply(mess.nonreg, id);
          if (m.quoted?.sender) m.mentionedJid.push(m.quoted.sender)
          if (isBan) return reply(mess.banned);
          if (isBanChat) return reply(mess.bangc);
          if (!m.isGroup) return reply(mess.grouponly)

          let user = m.sender
          const cara = "cara"
          const daily = await eco.daily(user, cara, 999); //give 999 for daily, can be changed

          if (daily.cd) return m.reply(`Du hast für heute bereits dein Geschenk einkassiert,komm wieder in ${daily.cdL}`); //cdL is already formatted cooldown Left

          m.reply(`Du hast 💎${daily.amount} einkassiert`);
        }
        break;

      case 'wallet': case 'purse': {
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!m.isGroup) return reply(mess.grouponly)

        if (m.quoted?.sender) m.mentionedJid.push(m.quoted.sender)

        const user = m.sender

        const cara = "cara"

        const balance = await eco.balance(user, cara); //Returns wallet, bank, and bankCapacity. Also creates a USer if it doesn't exist.

        await m.reply(`👛 ${pushname}'s Geldbörse:\n\n_💎${balance.wallet}_`);

      }

        break;


      case 'bank': case 'levee': {
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (m.quoted?.sender) m.mentionedJid.push(m.quoted.sender)

        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!m.isGroup) return reply(mess.grouponly)


        const user = m.sender
        const cara = "cara"
        const balance = await eco.balance(user, cara); //Returns wallet, bank, and bankCapacity. Also creates a USer if it doesn't exist.
        await m.reply(`🏦 ${pushname}'s Bankkonto:\n\n_💎${balance.bank}/${balance.bankCapacity}_`);
      }
        break;


      case 'capacity': case 'bankupgrade':
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!m.isGroup) return reply(mess.grouponly)

        {


          //if (!isCreator) return reply(mess.botowner)
          if (!text) return m.reply(`💴 Bank-Kapazität 💳\n\n1 | 1000 sp = 💎100\n\n2 | 10000 sp = 💎1000\n\n3 | 100000 sp = 💎10000\n\nBeispiel- ${prefix}capacity 1 OR ${prefix}bankupgrade 1000`)
          if (m.quoted?.sender) m.mentionedJid.push(m.quoted.sender)
          const user = m.mentionedJid[0] ? m.mentionedJid[0] : m.sender
          const cara = "cara"
          let value = text.trim();
          let k = parseInt(value)
          const balance = await eco.balance(user, cara)
          switch (value) {
            case '1000':
            case '1':
              if (k > balance.wallet) return m.reply(`Du musst 💎100 bezahlen, um die Bankkapazität zu erhöhen ~ 1000 sp`);
              const deduct1 = await eco.deduct(user, cara, 100);
              const add1 = eco.giveCapacity(user, cara, 1000);
              await m.reply(`*${pushname}* deine Kapazität wurde auf 1000 💎 erhöht`)
            case '10000':
            case '2':
              if (k > balance.wallet) return m.reply(`Du musst 💎1000 bezahlen, um die Bankkapazität zu erhöhen ~ 10000 sp`);
              const deduct2 = await eco.deduct(user, cara, 1000);
              const add2 = eco.giveCapacity(user, cara, 10000);
              await m.reply(`*${pushname}* deine Kapazität wurde auf 10000 💎 erhöht`)
            case '100000':
            case '3':
              if (k > balance.wallet) return m.reply(`Du musst 💎10000 bezahlen, um die Bankkapazität zu erhöhen ~ 100000 sp`);
              const deduct3 = await eco.deduct(user, cara, 10000);
              const add3 = eco.giveCapacity(user, cara, 100000);
              await m.reply(`*${pushname}* deine Kapazität wurde auf 100000 💎 erhöht`)
          }
        }
        break;


      case 'deposit':
      case 'pay-in': {
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!m.isGroup) return reply(mess.grouponly)


        if (m.quoted?.sender) m.mentionedJid.push(m.quoted.sender)
        if (!text) return reply("Gebe den Betrag an, den du einzahlen möchtest!");
        const texts = text.trim();
        const user = m.sender;
        const cara = 'cara'
        const deposit = await eco.deposit(user, cara, texts);
        if (deposit.noten) return reply('Du kannst keinen Betrag einzahlen den du nicht besitzt...'); //if user states more than whats in his wallet
        m.reply(`Du hast Erfolgreich 💎${deposit.amount} eingezahlt.`)
      }
        break;


      case 'withdraw': case 'withdrawal': {
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!m.isGroup) return reply(mess.grouponly)


        if (m.quoted?.sender) m.mentionedJid.push(m.quoted.sender)
        const user = m.sender
        if (!text) return reply("Geben den Betrag an, den du abheben möchtest!");
        const query = text.trim();
        const cara = 'cara'
        const withdraw = await eco.withdraw(user, cara, query);
        if (withdraw.noten) return reply('🏧 Du hast zu wenig Guthaben.'); //if user states more than whats in his wallet
        const add = eco.give(user, cara, query);
        m.reply(`💎${withdraw.amount} wurde abgehoben.`)

      }
        break;


      case 'rob': case 'attack':
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!m.isGroup) return reply(mess.grouponly)

        {

          if (!text) return m.reply(`Verwende ${prefix}rob @user`)
          const target =
            m.quoted && m.mentionedJid.length === 0
              ? m.quoted.sender
              : m.mentionedJid[0] || null;
          if (!target || target === m.sender) return reply("Was versuchst du zu tun?!")
          if (m.quoted?.sender && !m.mentionedJid.includes(m.quoted.sender)) m.mentionedJid.push(m.quoted.sender)
          while (m.mentionedJid.length < 2) m.mentionedJid.push(m.sender)

          const user1 = m.sender
          const user2 = target
          const k = 250
          const balance1 = await eco.balance(user1, cara)
          const balance2 = await eco.balance(user2, cara)
          const typ = ['ran', 'rob', 'caught'];
          const random = typ[Math.floor(Math.random() * typ.length)];
          if (k > balance1.wallet) return m.reply(`Du hast nicht genug Geld, um zu bezahlen, falls du erwischt wirst.`);
          if (k > balance2.wallet) return m.reply(`Dein Opfer ist zu arm 🤷🏽‍♂️ lass ihn in Frieden.`);
          let tpy = random
          switch (random) {
            case 'ran':
              await m.reply(`Dein Opfer ist entkommen, sei das nächste Mal furchterregender.`)
          }
        }
        break;


      case 'transfer': case 'give': {
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!m.isGroup) return reply(mess.grouponly)
        let value = text.trim().split(" ");
        if (value[0] === "") return m.reply(`Verwende ${prefix}transfer 100 @user`);
        const target =
          m.quoted && m.mentionedJid.length === 0
            ? m.quoted.sender
            : m.mentionedJid[0] || null;
        if (!target || target === m.sender) return reply("Was versuchst du da?!")
        if (m.quoted?.sender && !m.mentionedJid.includes(m.quoted.sender)) m.mentionedJid.push(m.quoted.sender)
        while (m.mentionedJid.length < 2) m.mentionedJid.push(m.sender)

        const user1 = m.sender
        const user2 = target
        const word = value[0];
        const code = value[1];
        let d = parseInt(word)
        if (!d) return reply("Überprüfe bitte deinen Text du verwendest den Befehl auf eine falschen Weise")

        const balance = await eco.balance(user1, cara);
        let a = (balance.wallet) < parseInt(word)
        //Returns wallet, bank, and bankCapacity. Also creates a USer if it doesn't exist.	
        if (a == true) return reply("Du hast nicht genügend Geld für eine Überweisung");

        const deduct = await eco.deduct(user1, cara, value[0]);
        const give = await eco.give(user2, cara, value[0]);
        m.reply(` Transaktion erfolgreich!`)

      }
        break;


      case 'wealth': case 'ritual': {
        if (!isCreator) return reply(mess.botowner)
        let value = text.trim().split(" ");
        if (value[0] === "") return m.reply(`Verwende: ${prefix}${command} 100 @user`);
        const target =
          m.quoted && m.mentionedJid.length === 0
            ? m.quoted.sender
            : m.mentionedJid[0] || null;
        const user = m.sender
        const user1 = target
        const cara = 'cara'
        const word = value[0];
        const code = value[1];
        let d = parseInt(word)
        if (!d) return reply("Überprüfe bitte deinen Text du verwendest den Befehl auf eine falschen Weise")

        const give1 = eco.give(user, cara, value[0])
        const give2 = await eco.give(user1, cara, value[0]);
        m.reply(`You are the wealthiest  *Daddy*`)
      }
        break;




      //
      case 'gamble':
      case 'lottery':
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!m.isGroup) return reply(mess.grouponly)

        const grouppId = '120363307567819322@g.us';
        const currentGroupId = m.chat;

        // Check if the message is from the specific group
        if (currentGroupId !== grouppId) {
          const groupLink = `https://chat.whatsapp.com/FyQh8yEL6Ad32kBrmjGP9Y`;
          return m.reply(`> Gambling ist nur in der Casino/Gamble Gruppe erlaubt.\n\nLink: ${groupLink}`);
        }

        const texts = text.trim().split(" ");
        const value = texts[0].toLowerCase();
        const opp = texts[1];
        const gg = parseInt(value);
        const user = m.sender;
        const caraa1 = 'cara';
        const balance = await eco.balance(user, caraa1);
        const g = balance.wallet > gg;
        const k = 50;
        const a = k > gg;
        const twice = gg * 2;
        const directions = ["up", "right", "left", "down", "up", "left", "down", "right", "up", "down", "right", "left"];
        const randomDirection = directions[Math.floor(Math.random() * directions.length)];

        if (texts[0] === "") {
          return reply(`Beispiel: ${prefix}gamble 100 Richtung(left, right, up, down)`);
        }
        if (!value) return reply("*Bitte geben den Betrag an, mit dem du spielen möchtest!*");
        if (!opp) return reply("Geben die Richtung an, auf die du wetten möchtest!");
        if (!gg) return reply("Du verwendest den Befehl auf eine falsche Weise.");
        if (m.quoted?.sender) m.mentionedJid.push(m.quoted.sender);
        if (!g) return m.reply(`Du hast nicht genügend 💎 Diamanten, um zu spielen`);
        if (a) return m.reply(`Sorry ${pushname}, Du kannst nur mit mehr als 💎50 spielen.`);

        if (randomDirection === opp) {
          await eco.give(user, caraa1, twice);
          m.reply(`*📈 Du hast 💎${twice} Gewonnen!*`);
        } else {
          await eco.deduct(user, caraa1, gg);
          m.reply(`*📉 Du hast 💎${gg} Verloren*`);
        }
        break;






      case 'slot': case 'spin': {
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!m.isGroup) return reply(mess.grouponly)
        const grouppId = '120363307135884850@g.us';
        const currentGroupId = m.chat;

        // Check if the message is from the specific group
        if (currentGroupId !== grouppId) {
          const groupLink = `https://chat.whatsapp.com/FbbSAIZvZPS2QF6mD9me57`;
          return m.reply(`> Slot/Spin ist nur in der Spin-Gruppe erlaubt.\n\nLink: ${groupLink}`);
        }
        // var today = new Date();
        //if (today.getDay() == 6 || today.getDay() == 5 || today.getDay() == 0) {
        if (text == 'help') return m.reply(`*1:* Verwende ${prefix}slot um zu spielen\n\n*2:* Du benötigst mindestens 💎100 Diamanten.`)
        if (text == 'money') return m.reply(`*1:* Kleiner Gewinn --> +💎20\n\n*2:* Kleiner Verlust --> -💎20\n\n*3:* Großer Gewinn --> +💎100\n\n*4:* Großer Verlust --> -💎50\n\n*5:* 🎉 Jackpot! --> +💎1000`)
        const fruit1 = ["🥥", "🍎", "🍇"]
        const fruit2 = ["🍎", "🍇", "🥥"]
        const fruit3 = ["🍇", "🥥", "🍎"]
        const fruit4 = ["🍇", "🥥", "🍎"]
        const lose = ['*Du bist eine Loser in diesem Spiel*\n\n_--> 🍍-🥥-🍎_', '*Völlig daneben*\n\n_--> 🥥-🍎-🍍_', '*Bist du ein Anfänger?*\n\n_--> 🍎-🍍-🥥_']
        const smallLose = ['*Kokosnüsse kann man nicht  🥥 auf einer Ananas 🍍-Farm ernten...*\n\n_--> 🍍>🥥<🍍_', '*Äpfel und Kokosnüsse sind nicht die beste Kombi*\n\n_--> 🍎>🥥<🍎_', '*Kokosnüsse und Äpfel sind kein guter Deal!*\n\n_--> 🥥>🍎<🥥_']
        const won = ['*Du hast einen Korb geerntet voll mit:*\n\n_--> 🍎+🍎+🍎_', '*Beeindruckend, scheint als wärst   du ein Spezialist im pflücken  von Kokosnüssen.*\n\n_--> 🥥+🥥+🥥_', '*Erstaunlich, du kannst Ananassaft für die Familie machen🤣*\n\n_--> 🍍+🍍+🍍_']
        const near = ['*Wow, du warst so nah dran, eine Ananas zu gewinnen*\n\n_--> 🍎-🍍+🍍_', '*Hmmm, du warst so nah dran, ein paar Äpfel zu gewinnen*\n\n_--> 🍎+🍎-🍍_']
        const jack = ['*🥳 JackPot 🤑*\n\n_--> 🍇×🍇×🍇×🍇_', '*🎉 Jaaackpooot!*\n\n_--> 🥥×🥥×🥥×🥥_', '*🎊 Du hast gerade denn Jackpot im Wert von 💎1000 geknackt!*']
        const user = m.sender
        const cara = "cara"
        const k = 100
        const balance1 = await eco.balance(user, cara)

        if (k > balance1.wallet) return m.reply(`> *Verwende ${prefix}slot um zu spielen.*\n*Du benötigst mindestens 💎100 Diamanten*.`);
        const f1 = fruit1[Math.floor(Math.random() * fruit1.length)];
        const f2 = fruit2[Math.floor(Math.random() * fruit2.length)];
        const f3 = fruit3[Math.floor(Math.random() * fruit3.length)];
        const f4 = fruit4[Math.floor(Math.random() * fruit4.length)];
        const mess1 = lose[Math.floor(Math.random() * lose.length)];
        const mess2 = won[Math.floor(Math.random() * won.length)];
        const mess3 = near[Math.floor(Math.random() * near.length)];
        const mess4 = jack[Math.floor(Math.random() * jack.length)];
        const mess5 = smallLose[Math.floor(Math.random() * smallLose.length)];

        if ((f1 !== f2) && f2 !== f3) {
          const deduct1 = await eco.deduct(user, cara, 50);
          m.reply(`${mess1}\n\n*Großer Verlust -->* _💎50_`)
        }
        else if ((f1 == f2) && f2 == f3) {
          const give1 = await eco.give(user, cara, 100);
          m.reply(`${mess2}\n*_Großer Gewinn -->* _💎100_`)
        }
        else if ((f1 == f2) && f2 !== f3) {
          const give2 = await eco.give(user, cara, 20);
          m.reply(`${mess3}\n*Kleiner Gewinn -->* _💎20_`)
        }
        else if ((f1 !== f2) && f1 == f3) {
          const deduct2 = await eco.deduct(user, cara, 20);
          m.reply(`${mess5}\n\n*Kleiner Verlust -->* _💎20_`)
        }
        else if ((f1 !== f2) && f2 == f3) {
          const give4 = eco.give(user, cara, 20);
          m.reply(`${mess3}\n\n*Kleiner Gewinn -->* _💎20_`)
        }
        else if (((f1 == f2) && f2 == f3) && f3 == f4) {
          const give5 = eco.give(user, cara, 1000);
          m.reply(`${mess4}\n\n_🎊 Jackpot --> _💎1000_`)
        }
        else {
          m.reply(`Verstehst du, was du tun musst?`)
        }
        //// }
        // else {
        //    m.reply(`*Du kannst dieses Spiel nur am Wochenenden spielen!*\n\n*🌿 Freitag*\n*🎏 Samstag*\n*🎐 Sonntag*`)
        //  }
      }
        break;





      case 'wallpaper':
      case 'animewallpaper':
      case 'animewall': {
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        reply(mess.waiting);
        if (!args.join(" ")) return reply("Please enter a term to search!");

        const { AnimeWallpaper } = require("anime-wallpaper");
        const wall = new AnimeWallpaper();
        const pages = [1, 2, 3, 4];
        const random = pages[Math.floor(Math.random() * pages.length)];
        const wallpapers = await wall.getAnimeWall4({ title: q, type: "sfw", page: pages }).catch(() => null);

        const maxImagesToSend = 15;
        const minImagesToSend = 5;
        const imagesToSend = Math.min(maxImagesToSend, Math.max(minImagesToSend, wallpapers.length));

        for (let i = 0; i < imagesToSend; i++) {
          let message = {
            image: { url: wallpapers[i].image },
            footer: `${BotName}`,
            headerType: 4
          };
          Phoenix.sendMessage(m.chat, message, { quoted: m });
        }
      }
        break;


      case 'wikimedia': case 'wikiimage': {
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!args.join(" ")) return reply("What picture are you looking for??")
        let { wikimedia } = require('./lib/scraper')
        anu = await wikimedia(args)
        hasil = anu[Math.floor(Math.random() * anu.length)]
        let buttons = [
          { buttonId: `${prefix}wikimedia ${args.join(" ")}`, buttonText: { displayText: 'Next Image' }, type: 1 }
        ]
        let buttonMessage = {
          image: { url: hasil.image },
          caption: `Title : ${hasil.title}\nSource : ${hasil.source}\nMedia Url : ${hasil.image}`,
          footer: `${BotName}`,
          buttons: buttons,
          headerType: 4
        }
        Phoenix.sendMessage(m.chat, buttonMessage, { quoted: m })
      }
        break;





      /*
            case 'chatgpt':
            case 'ai':
            case 'gpt': {
              if (!isRegistered) return await reply(mess.nonreg, id);
              if (isBan) return reply(mess.banned);
              if (isBanChat) return reply(mess.bangc);
      
              const randomEmoji = manyemojis[Math.floor(Math.random() * manyemojis.length)];
      
              if (!q) return m.reply(`Bitte gebe einen Text ein. Beispiel: ${prefix + command} Hallo, *ChatGPT*`);
      
              try {
                const apiUrl1 = `https://vihangayt.me/tools/chatgpt2?q=${encodeURIComponent(q)}`;
      
                const response1 = await fetch(apiUrl1);
                const responseData1 = await response1.json();
      
                let message = "";
      
                if (response1.status === 200 && responseData1 && responseData1.status === true && responseData1.data) {
                  message = responseData1.data;
                } else {
                  return reply("Sorry, I couldn't fetch a response from the API at the moment.");
                }
      
                const me = m.sender;
                await Phoenix.sendMessage(m.chat, { text: message, mentions: [me] }, { quoted: m });
      
              } catch (error) {
                console.error(error);
                reply("An error occurred while fetching the response from the API.");
              }
            }
              break;
      */


      case 'groupsetting':
      case 'groupsettings':
        {
          if (!isRegistered) return await reply(mess.nonreg, id);
          let anuuuuu = `
Aloha! @${m.sender.split("@")[0]}

*[ INFORMATION ]*
Group Settings Menu`
          let msg = generateWAMessageFromContent(from, {
            viewOnceMessage: {
              message: {
                "messageContextInfo": {
                  "deviceListMetadata": {},
                  "deviceListMetadataVersion": 2
                },
                interactiveMessage: proto.Message.InteractiveMessage.create({
                  body: proto.Message.InteractiveMessage.Body.create({
                    text: anuuuuu
                  }),
                  footer: proto.Message.InteractiveMessage.Footer.create({
                    text: "_Entwickelt von Team-Phoenix_"
                  }),
                  header: proto.Message.InteractiveMessage.Header.create({
                    title: "",
                    subtitle: "",
                    hasMediaAttachment: false
                  }),
                  nativeFlowMessage: proto.Message.InteractiveMessage.NativeFlowMessage.create({
                    buttons: [
                      {
                        "name": "single_select",
                        "buttonParamsJson":
                          `{"title":"List Menu ⎙",
"sections":[{"title":"Phoenix-Bot",
"highlight_label": "Favorite Request",
"rows":[{"header":"",
"title":"Group",
"description":"Group open/close",
"id":"${prefix}group"},
{"header":"",
"title":"Antilink",
"description":"Antilinkall on/off",
"id":"${prefix}antilinkall on "},
{"header":"",
"title":"Hidetag",
"id":"${prefix}hidetag"}]
}]
}`
                      },
                    ],


                  }),
                  contextInfo: {
                    mentionedJid: [m.sender],
                    //forwardingScore: 999,
                    //isForwarded: false,
                    forwardedNewsletterMessageInfo: {
                      //newsletterJid: '120363236214682540@newsletter',
                      //newsletterName: 'Phoenix-Bot',
                      serverMessageId: 143
                    }
                  }
                })
              }
            }
          }, {})

          await Phoenix.relayMessage(msg.key.remoteJid, msg.message, {
            messageId: msg.key.id
          })

        }
        break;


      case 'emojimix':
      case 'emoji': {
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);

        if (!q) m.reply(`*Beispiel :* ${prefix + command} 😊+🌹`)
        let [emoji1, emoji2] = q.split`+`
        let kuntuh = await fetchJson(`https://tenor.googleapis.com/v2/featured?key=AIzaSyAyimkuYQYF_FXVALexPuGQctUWRURdCYQ&contentfilter=high&media_filter=png_transparent&component=proactive&collection=emoji_kitchen_v5&q=${encodeURIComponent(emoji1)}_${encodeURIComponent(emoji2)}`)
        for (let res of kuntuh.results) {
          let encmedia = await Phoenix.sendImageAsSticker(from, res.url, m, { packname: global.packname, author: global.author, categories: res.tags })
          await fs.unlinkSync(encmedia)
        }
      }
        break;



      //-----------------------------------------------------------------------------------------------------------------------------------//


      //
      case 'nsfw': {
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!m.isGroup) return reply(mess.grouponly);
        if (!isBotAdmins) return reply(mess.botadmin);
        if (!isAdmins && !isCreator) return reply(mess.useradmin);

        if (args[0] === "on") {
          if (AntiNsfw) return reply('Bereits aktiviert');
          ntnsfw.push(from);
          reply('Aktiviert, aber bro wir sind nicht Neele bah digga als ob wir sowas haben, wir sagen dazu: *Dont be a pervert Baka!*');
        } else if (args[0] === "off") {
          if (!AntiNsfw) return reply('Bereits deaktiviert');
          let off = ntnsfw.indexOf(from);
          ntnsfw.splice(off, 1);
          reply('NSFW Deaktiviert!');
        } else {
          m.reply(`NSFW(not safe for work) feature has been enabled in this group, which means anyone here can accesss Adult commands!\n\nPlease use *'${prefix}nsfw on*' to enable NSFW commands or *'${prefix}nsfw off'* to disable them.`);
        }
      }
        break;



      //-----------------------------------------------------------------------------------------------------------------------------------//


      case 'getcase':
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (!isCreator) return reply(mess.botowner)
        if (isBan) return reply(mess.banned);


        if (isBanChat) return reply(mess.bangc);



        const getCase = (cases) => {
          return "case" + `'${cases}'` + fs.readFileSync("Core.js").toString().split('case \'' + cases + '\'')[1].split("break;")[0] + "break;"
        }
        m.reply(`${getCase(q)}`)
        break;




      case 'deleteall': case 'delall': case 'delete': case 'del': {
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!isBotAdmins) return reply(mess.botadmin);
        if (!isAdmins && !isCreator) return reply(mess.useradmin)

        if (!m.quoted) return reply('Bitte markiere eine Nachricht!')
        let { chat, fromMe, id } = m.quoted

        const key = {
          remoteJid: m.chat,
          fromMe: false,
          id: m.quoted.id,
          participant: m.quoted.sender
        }

        await Phoenix.sendMessage(m.chat, { delete: key })
      }
        break;



      //////////////////////////////////////////////////////////////////////
      /////////////////////////////////////////////////////////////////////



      case 'ghstalk': case 'githubstalk': case 'github': {
        if (!isRegistered) return await reply(mess.nonreg, id);

        if (!q) return m.reply(`Give me a user name like *${prefix}github Exiqonbotz*`)

        gitdata = await githubstalk.githubstalk(`${q}`)
        Phoenix.sendMessage(m.chat, {
          image: { url: gitdata.profile_pic }, caption:
            `*ㅤㅤㅤ|ㅤㅤㅤGithub Info ㅤㅤㅤ|\*

  🚩 Id : ${gitdata.id}
  🔖 Nickname : ${gitdata.nickname}
  🔖 Username : ${gitdata.username}
  ✨ Bio : ${gitdata.bio}
  🏢 Company : ${gitdata.company}
  📍 Location : ${gitdata.location}
  📧 Email : ${gitdata.email}
  🔓 Public Repo : ${gitdata.public_repo}
  🔐 Public Gists : ${gitdata.public_gists}
  💕 Followers : ${gitdata.followers}
  👉 Following : ${gitdata.following}`
        }, { quoted: m })
      }
        break;



      case 'listpc': {
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);

        let anu = await store.chats.all().filter(v => v.id.endsWith('.net')).map(v => v)
        let teks = ` 「  │𝐏𝐇𝐎𝐄𝐍𝐈𝐗│𝐁𝐎𝐓│𝐕1️⃣ 🌃 User Liste  」\n\nDiese Anzahl ${anu.length} von Usern verwenden Phoenix in Privaten Chats.`
        for (let i of anu) {
          teks += `\n\nProfil : @${i.id.split('@')[0]}\nChat : ${i.unreadCount}\nLetzte Interaktion : ${moment(i.conversationTimestamp * 1000).tz("Europe/Berlin").format("DD/MM/YYYY HH:mm:ss")}`
        }
        Phoenix.sendTextWithMentions(m.chat, teks, m)
      }
        break;


      case 'listgc': {
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);

        let anu = await store.chats.all().filter(v => v.id.endsWith('@g.us')).map(v => v.id)
        let teks = ` 「   │𝐏𝐇𝐎𝐄𝐍𝐈𝐗│𝐁𝐎𝐓│𝐕1️⃣ 🌃 group user list  」\n\nTotal ${anu.length} users are using bot in Groups.`
        for (let i of anu) {
          let metadata = await Phoenix.groupMetadata(i)
          if (metadata.owner === "undefined") {
            loldd = false
          } else {
            loldd = metadata.owner
          }
          teks += `\n\nName : ${metadata.subject ? metadata.subject : "undefined"}\nOwner : ${loldd ? '@' + loldd.split("@")[0] : "undefined"}\nID : ${metadata.id ? metadata.id : "undefined"}\nMade : ${metadata.creation ? moment(metadata.creation * 1000).tz('Europe/Berlin').format('DD/MM/YYYY HH:mm:ss') : "undefined"}\nMember : ${metadata.participants.length ? metadata.participants.length : "undefined"}`
        }
        Phoenix.sendTextWithMentions(m.chat, teks, m)
      }
        break;

      case 'speedtest':
      case 'speedcheck':
        if (!isRegistered) return await reply(mess.nonreg, id);
        m.reply(`Bitte warten ${pushname} Teste Geschwindigkeit... ⚙️`);

        try {
          const FastSpeedtest = require('fast-speedtest-api');


          // Geschwindigkeitstest
          const speedtest = new FastSpeedtest({
            token: 'YXNkZmFzZGxmbnNkYWZoYXNkZmhrYWxm', // Ihr API-Token hier
            verbose: true,
            timeout: 10000,
            https: true,
            urlCount: 5,
            bufferSize: 8,
            unit: FastSpeedtest.UNITS.Mbps
          });

          const speed = await speedtest.getSpeed();

          // Ergebnisse an den Benutzer senden
          const result = `Download Speed: ${speed} Mbps`;
          await m.reply(result);
        } catch (err) {
          console.error(err);
          // Fehlerbehandlung: Eine Nachricht bei internem Fehler senden
          m.reply(`Beim Speedtest ist ein interner Fehler aufgetreten.`);
        }
        break;

      /**
       * Class::PromisePing
       * @param {string} addr - Hostname or ip addres
       * @param {PingConfig} config - Configuration for command ping
       * @return {Promise}
       */


      case 'speed':
        if (!isRegistered) return await reply(mess.nonreg, id);
        m.reply(`Bitte warten, Ping wird berechnet...`);
        try {
          const { exec } = require('child_process');

          // Ping-Befehl für Linux ausführen
          exec('ping -c 4 google.com', (error, stdout, stderr) => {
            if (error) {
              console.error(`Fehler beim Ausführen des Ping-Befehls: ${error.message}`);
              m.reply(`Bei der Geschwindigkeitsüberprüfung ist ein Fehler aufgetreten.`);
              return;
            }
            if (stderr) {
              console.error(`Fehlerausgabe des Ping-Befehls: ${stderr}`);
              m.reply(`Bei der Geschwindigkeitsüberprüfung ist ein Fehler aufgetreten.`);
              return;
            }

            // Ping-Ergebnisse aus der Standardausgabe extrahieren
            const pingOutputLines = stdout.split('\n');
            const timeLine = pingOutputLines.find(line => line.includes('time='));
            const timeMatch = /time=([\d.]+) ms/.exec(timeLine);
            const pingTime = timeMatch ? parseFloat(timeMatch[1]) : null;

            // Ergebnisse an den Benutzer senden
            if (pingTime !== null) {
              m.reply(`Ping: ${pingTime} ms`);
            } else {
              m.reply(`Ping-Ergebniss konnte nicht analysiert werden.`);
            }
          });
        } catch (err) {
          console.error(err);
          m.reply(`Bei der Geschwindigkeitsüberprüfung ist ein interner Fehler aufgetreten.`);
        }
        break;






      case 'status': case 'post': {
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (!isCreator) return reply(mess.owner)
        if (!quoted) return m.reply(`Send/reply Image With Caption ${prefix}status`)
        if (/video/.test(mime)) {
          if ((quoted.msg || quoted).seconds > 30) return reply('Maximum 30 seconds video is allowed!')
        }
        const messageType = Object.keys(m.message)[0]
        if (messageType === 'imageMessage') {
          const media = await downloadMediaMessage(m, 'media', {}, { logger, reuploadRequest: sock.updateMediaMessage })
          await writeFile('./image.jpeg', media)
          await Phoenix.sendMessage(botNumber, 'status@broadcast', { url: './image.jpeg', media }).catch((err) => fs.unlinkSync(media))
          m.reply(`*✨ ${pushname}...!! Posted On My Status ✨*`);
        }
        else if (messageType === 'videoMessage') {
          const media = await downloadMediaMessage(m, 'media', {}, { logger, reuploadRequest: sock.updateMediaMessage })
          await writeFile('./video.mp4', media)
          await Phoenix.sendMessage(botNumber, 'status@broadcast', { url: 'video.mp4', media }).catch((err) => fs.unlinkSync(media))
          m.reply(`*✨ ${pushname}...!! Posted On My Status ✨*`);
        }
        else {
          m.reply(`an error occurred`)
        }

      }
        break;



      ////////////////////////////////////////////////////////////////////////
      ////////////////////////////////////////////////////////////////////////




      case 'fliptext': {
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (args.length < 1) return m.reply(`Beispiel:\n${prefix}fliptext ${OwnerName}`)
        quere = args.join(" ")
        flipe = quere.split('').reverse().join('')
        m.reply(`\`\`\`「  Text Flipper Tool  」\`\`\`\n*Input text :*\n${quere}\n*Fliped text :*\n${flipe}`)
      }
        break;





      case 'leveling':
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!m.isGroup) return reply(mess.grouponly);
        if (!isAdmins && !isCreator) return reply(mess.useradmin)
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (args.length < 1) return reply('Tippe on, zum *Aktivieren*\nTippe off, zum *Deaktivieren*')
        if (args[0] === 'on') {
          if (isLeveling) return reply(`Bereits aktiviert`)
          _leveling.push(from)
          fs.writeFileSync('./database/user/level.json', JSON.stringify(_leveling))
          reply('Level aktiviert')
        } else if (args[0] === 'off') {
          let anu = _leveling.indexOf(from)
          _leveling.splice(anu, 1)
          fs.writeFileSync('./database/user/level.json', JSON.stringify(_leveling))
          reply('Level aktiviert')
        }
        break;


      ////////////////////////////////////////////////////////////////////////////






      case 'antilinkall': {
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!m.isGroup) return reply(mess.grouponly);
        if (!isBotAdmins) return reply(mess.botadmin);
        if (!isAdmins && !isCreator) return reply(mess.useradmin);

        const groupId = from;

        if (args[0] === "on") {
          if (antilinkData.includes(groupId)) return reply('Bereits aktiviert');

          antilinkData.push(groupId);
          saveAntilinkData();

          reply('Antilink Aktiviert!');

          var groupe = await Phoenix.groupMetadata(from);
          // var members = groupe['participants'];
          // var mems = members.map(adm => adm.id.replace('c.us', 's.whatsapp.net'));

          Phoenix.sendMessage(from, {
            text: `\`\`\`「 Achtung 」\`\`\`\n\nAntilink System Aktiviert!`,

          }, { quoted: m });

        } else if (args[0] === "off") {
          if (!antilinkData.includes(groupId)) return reply('Bereits deaktiviert');

          antilinkData = antilinkData.filter(id => id !== groupId);
          saveAntilinkData();

          reply('Antilink Deaktiviert!');
        } else {
          let textmsg = 'Tippe ' + `${prefix}${command}` + ' on zum aktivieren oder tippe ' + `${prefix + command}` + ' off zum deaktivieren';
          await Phoenix.sendMessage(m.chat, { text: `${textmsg}` }, `${global.BotName}`, m);
        }
      }
        break;






      /////////////////////////////////////////////////////////////////////////////////////////////
      ///////////////////////////////////////////////////////////////////////////////////////////////////////////////



      //-----------------------------------------------------------------------------------------------------------------------------------//


      case 'listonline': case 'listaktive': case 'here': {
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!m.isGroup) return reply(mess.grouponly);

        let id = args && /\d+\-\d+@g.us/.test(args[0]) ? args[0] : m.chat
        let online = [...Object.keys(store.presences[id]), botNumber]
        let liston = 1
        Phoenix.sendText(m.chat, '  「 *Aktive Member* 」\n\n' + online.map(v => `${liston++} . @` + v.replace(/@.+/, '')).join`\n`, m, { mentions: online })
      }
        break;


      //-----------------------------------------------------------------------------------------------------------------------------------//




      //-----------------------------------------------------------------------------------------------------------------------------------//


      //group moderation

      case 'banchat': case 'bangroup': case 'banmode': {
        if (isBan) return reply(mess.banned);
        if (!isCreator && !isSup) return reply(mess.botowner);

        if (args[0] === "on") {
          if (isBanChat) return reply('Diese Gruppe ist bereits Gesperrt!');
          banchat.push(from);
          reply('Befehle für diese Gruppe sind gesperrt!');

          var groupe = await Phoenix.groupMetadata(from);
          var members = groupe['participants'];
          var mems = [];
          members.map(async adm => {
            mems.push(adm.id.replace('c.us', 's.whatsapp.net'));
          });

          Phoenix.sendMessage(from, { text: `\`\`\`「 Achtung 」\`\`\`\n\nBefehle für diese Gruppe wurden gesperrt!`, contextInfo: { mentionedJid: mems } }, { quoted: m });
        } else if (args[0] === "off") {
          if (!isBanChat) return reply('Die Gruppe wurde erfolgreich ist bereits entsperrt!');  /// WARTE
          let off = banchat.indexOf(from);
          banchat.splice(off, 1);
          reply('Die Gruppe wurde entsperrt!');
        } else {
          reply('Please choose either *"on"* or *"off"* to ban or unban the group from using the bot.');
        }
      }
        break;


      case 'setname': case 'setsubject': {
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!m.isGroup) return reply(mess.grouponly);
        if (!isBotAdmins) return reply(mess.botadmin);
        if (!isAdmins && !isCreator) return reply(mess.useradmin)
        if (!text) return reply('Pls enter -setname <New Group Name>  to change this Group Name')
        await Phoenix.groupUpdateSubject(m.chat, text).then((res) => reply(mess.jobdone)).catch((err) => reply(jsonformat(err)))
      }
        break;


      case 'block': {
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!isCreator) return reply(mess.botowner)
        let users = m.mentionedJid[0] ? m.mentionedJid[0] : m.quoted ? m.quoted.sender : text.replace(/[^0-9]/g, '') + '@s.whatsapp.net'
        await Phoenix.updateBlockStatus(users, 'block').then((res) => reply(jsonformat(res))).catch((err) => reply(jsonformat(err)))
      }
        break;


      case 'unblock': {
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!isCreator) return reply(mess.botowner)
        let users = m.mentionedJid[0] ? m.mentionedJid[0] : m.quoted ? m.quoted.sender : text.replace(/[^0-9]/g, '') + '@s.whatsapp.net'
        await Phoenix.updateBlockStatus(users, 'unblock').then((res) => reply(jsonformat(res))).catch((err) => reply(jsonformat(err)))
      }
        break;


      case 'setdesc': case 'setdesk': {
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!m.isGroup) return reply(mess.grouponly);
        if (!isBotAdmins) return reply(mess.botadmin);
        if (!isAdmins && !isCreator) return reply(mess.useradmin)
        if (!text) return reply('Pls enter -setname <New Group Description>  to change this Group Description.')
        await Phoenix.groupUpdateDescription(m.chat, text).then((res) => reply(mess.jobdone)).catch((err) => reply(jsonformat(err)))
      }
        break;


      case 'setgrouppb': case 'setgruppp': case 'setgcpp': {
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!m.isGroup) return reply(mess.grouponly);
        if (!isBotAdmins) return reply(mess.botadmin);
        if (!isAdmins && !isCreator) return reply(mess.useradmin)
        if (!quoted) return m.reply(`Send/reply Image With Caption ${prefix + command}`)
        if (!/image/.test(mime)) return m.reply(`Send/reply Image With Caption ${prefix + command} to change the Profile Pic of this group.`)
        if (/webp/.test(mime)) return m.reply(`Send/reply Image With Caption ${prefix + command} to change the Profile Pic of this group.`)
        let media = await Phoenix.downloadAndSaveMediaMessage(quoted)
        await Phoenix.updateProfilePicture(m.chat, { url: media }).catch((err) => fs.unlinkSync(media))
        reply(mess.jobdone)
      }
        break;


      case 'tagall': case 'all': {
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!m.isGroup) return reply(mess.grouponly);
        if (!isAdmins && !isCreator) return reply(mess.useradmin)
        let teks = `「 Achtung 」

*Nachricht : ${args.join(" ") ? args.join(" ") : 'Keine Nachricht'}*\n\n`
        for (let mem of participants) {
          teks += `» @${mem.id.split('@')[0]}\n`
        }
        Phoenix.sendMessage(m.chat, { text: teks, mentions: participants.map(a => a.id) }, { quoted: m })
      }
        break;


      case 'hidetag': case 'tag': case 'ooo': {
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!m.isGroup) return reply(mess.grouponly);
        if (!isAdmins && !isCreator) return reply(mess.useradmin)
        Phoenix.sendMessage(m.chat, { text: args.join(" ") ? args.join(" ") : '', mentions: participants.map(a => a.id) }, { quoted: m })
      }
        break;


      case 'tagadmins': case 'admins': {
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!m.isGroup) return reply(mess.grouponly);
        if (!text) return m.reply(`*│𝐏𝐇𝐎𝐄𝐍𝐈𝐗│𝐁𝐎𝐓│𝐕1️⃣ 🌃*`)
        let teks =
          `          *「 Tag Admins 」*\n\n*Nachricht : ${text}*\n\n`
        for (let mem of groupAdmins) {
          teks += `👑 @${mem.split('@')[0]}\n`
        }
        Phoenix.sendMessage(m.chat, { text: teks, mentions: groupAdmins }, { quoted: m })
      }
        break;







      case 'nowa': case 'find': case 'stalk': case 'stalknumber': {
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (isBan) return reply(mess.banned);
        if (!args[0]) return m.reply(`Use command like: ${prefix}stalk <number>xxx`)
        var inputnumber = args[0]
        if (!inputnumber.includes('x')) return reply('You did not added x')
        m.reply(`Searching for WhatsApp account in given range...`)
        m.reply(`Please wait while i fetch details...`)
        function countInstances(string, word) {
          return string.split(word).length - 1;
        }
        var number0 = inputnumber.split('x')[0]
        var number1 = inputnumber.split('x')[countInstances(inputnumber, 'x')] ? inputnumber.split('x')[countInstances(inputnumber, 'x')] : ''
        var random_length = countInstances(inputnumber, 'x')
        var randomxx;
        if (random_length == 1) {
          randomxx = 10
        } else if (random_length == 2) {
          randomxx = 100
        } else if (random_length == 3) {
          randomxx = 1000
        }
        var nomerny = `*『 List of Whatsapp Numbers 』*\n\n`
        var nobio = `\n*Bio:* || \nHey there! I am using WhatsApp.\n`
        var nowhatsapp = `\n*Numbers with no WhatsApp account within the range you provided*\n`
        for (let i = 0; i < randomxx; i++) {
          var nu = ['1', '2', '3', '4', '5', '6', '7', '8', '9']
          var status1 = nu[Math.floor(Math.random() * nu.length)]
          var status2 = nu[Math.floor(Math.random() * nu.length)]
          var status3 = nu[Math.floor(Math.random() * nu.length)]
          var dom4 = nu[Math.floor(Math.random() * nu.length)]
          var rndm;
          if (random_length == 1) {
            rndm = `${status1}`
          } else if (random_length == 2) {
            rndm = `${status1}${status2}`
          } else if (random_length == 3) {
            rndm = `${status1}${status2}${status3}`
          } else if (random_length == 4) {
            rndm = `${status1}${status2}${status3}${dom4}`
          }
          let anu = await Phoenix.onWhatsApp(`${number0}${i}${number1}@s.whatsapp.net`);
          var anuu = anu.length !== 0 ? anu : false
          try {
            try {
              var anu1 = await Phoenix.fetchStatus(anu[0].jid)
            } catch {
              var anu1 = '401'
            }
            if (anu1 == '401' || anu1.status.length == 0) {
              nobio += `wa.me/${anu[0].jid.split("@")[0]}\n`
            } else {
              nomerny += `🪄 *Nummer:* wa.me/${anu[0].jid.split("@")[0]}\n🔹 *Bio :* ${anu1.status}\n🔸 *Updated On :* ${moment(anu1.setAt).tz('Europe/Berlin').format('HH:mm:ss DD/MM/YYYY')}\n\n`
            }
          } catch {
            nowhatsapp += `${number0}${i}${number1}\n`
          }
        }
        m.reply(`${nomerny}${nobio}${nowhatsapp}`)
      }
        break;


      case 'grouplink': case 'gclink': {
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!m.isGroup) return reply(mess.grouponly);
        if (!isBotAdmins) return reply(mess.botadmin);
        let response = await Phoenix.groupInviteCode(m.chat)
        Phoenix.sendMessage(m.chat, {
          text: `*Gruppen name:* *${groupMetadata.subject}* \n\n*Gruppenlink :* \nhttps://chat.whatsapp.com/${response}l`, "contextInfo": {
            mimetype: "image/jpeg",
            text: `${global.OwnerName}`,
            "forwardingScore": 1000000000,
            isForwarded: true,
            sendEphemeral: true,
            "externalAdreply": {
              "title": `${global.BotName}`,
              "body": `${global.WaterMark}`,
              "previewType": "PHOTO",
              "thumbnailUrl": Thumb,
              "thumbnail": Thumb,
              "sourceUrl": `${global.websitex}`
            }
          }
        }, { quoted: m, detectLink: true })
      }
        break;


      case 'resetlinkgc':
      case 'resetlinkgroup':
      case 'resetlinkgrup':
      case 'revoke':
      case 'resetlink':
      case 'resetgrouplink':
      case 'resetgclink':
      case 'resetgrouplink': {
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!m.isGroup) return reply(mess.grouponly);
        if (!isBotAdmins) return reply(mess.botadmin);
        if (!isAdmins && !isCreator) return reply(mess.useradmin)
        Phoenix.groupRevokeInvite(m.chat)
      }
        break;


      case 'group': case 'grup': {
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!m.isGroup) return reply(mess.grouponly);
        if (!isBotAdmins) return reply(mess.botadmin);
        if (!isAdmins && !isCreator) return reply(mess.useradmin)
        if (args[0] === 'close') {
          await Phoenix.groupSettingUpdate(m.chat, 'announcement').then((res) => m.reply(`*_DIE GRUPPE WURDE ERFOLGREICH GESCHLOSSEN_*.`)).catch((err) => reply(jsonformat(err)))
        } else if (args[0] === 'open') {
          await Phoenix.groupSettingUpdate(m.chat, 'not_announcement').then((res) => m.reply(`*_DIE GRUPPE WURDE ERFOLGREICH GEÖFFNET_*.`)).catch((err) => reply(jsonformat(err)))
        } else {

          let buttonMessage = {
            image: BotLogo,
            jpegThumbnail: Thumb,
            caption: `*「 ${global.BotName} 」*\n\n_Group Setting Changer tool_:\n\nIf you want to Group close */group close*\n\nIf you want to Group Open */group open*`,
            footer: `${BotName}`,
            headerType: 4
          }
          Phoenix.sendMessage(m.chat, buttonMessage, { quoted: m })
        }
      }
        break;


      case 'promote': case 'admin': {
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!m.isGroup) return reply(mess.grouponly);
        if (!isBotAdmins) return reply(mess.botadmin);
        if (!isAdmins && !isCreator) return reply(mess.useradmin)
        let users = m.mentionedJid[0] ? m.mentionedJid[0] : m.quoted ? m.quoted.sender : text.replace(/[^0-9]/g, '') + '@s.whatsapp.net'
        let userrs = m.mentionedJid[0] ? m.mentionedJid[0].replace('@s.whatsapp.net', '') : m.quoted ? m.quoted.sender.replace('@s.whatsapp.net', '') : text.replace(/[^0-9]/g, '');

        await Phoenix.groupParticipantsUpdate(m.chat, [users], 'promote').then((res) => reply(`+${userrs} ist jetzt ein Admin!`)).catch((err) => reply('Error!'))
      }
        break;


      case 'demote': case 'unadmin': {
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!m.isGroup) return reply(mess.grouponly);
        if (!isBotAdmins) return reply(mess.botadmin);
        if (!isAdmins && !isCreator) return reply(mess.useradmin)
        let users = m.mentionedJid[0] ? m.mentionedJid[0] : m.quoted ? m.quoted.sender : text.replace(/[^0-9]/g, '') + '@s.whatsapp.net'
        let userrs = m.mentionedJid[0] ? m.mentionedJid[0].replace('@s.whatsapp.net', '') : m.quoted ? m.quoted.sender.replace('@s.whatsapp.net', '') : text.replace(/[^0-9]/g, '');
        await Phoenix.groupParticipantsUpdate(m.chat, [users], 'demote').then((res) => reply(`+${userrs} ist kein Admin mehr!`)).catch((err) => reply('Error!'))
      }
        break;


      case 'kickk': {
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!m.isGroup) return reply(mess.grouponly);
        if (!isBotAdmins) return reply(mess.botadmin);
        if (!isAdmins && !isCreator) return reply(mess.useradmin)
        let users = m.mentionedJid[0] ? m.mentionedJid[0] : m.quoted ? m.quoted.sender : text.replace(/[^0-9]/g, '') + '@s.whatsapp.net'
        await Phoenix.groupParticipantsUpdate(m.chat, [users], 'remove')
      }
        break;


// join command: This command allows a user to request the bot to join a WhatsApp group via an invitation link.
case 'join': {
  if (!isRegistered) {
      return await reply(mess.nonreg, id); // Check if the user is registered
  }
  if (isBan) {
      return reply(mess.banned); // Check if the user is banned
  }
  if (isBanChat) {
      return reply(mess.bangc); // Check if the chat is banned
  }

  if (!args[0]) {
      return m.reply('Wo ist der Link?'); // Check if the invitation link is provided
  }

  const vdd = args[0];
  const vcc = vdd.split('https://chat.whatsapp.com/')[1];
  if (!vcc) {
      return reply('Link ungültig!'); // Check if the provided link is valid
  }

  console.log(isCreator);

  if (isSup) { // Check if the user has a specific privilege
      Phoenix.groupAcceptInvite(vcc)
          .then(async (res) => reply(jsonformat(res)))
          .catch(err => {
              console.error('Fehler beim Beitreten zur Gruppe:', err);
              m.reply('Fehler beim Beitreten zur Gruppe.');
          });
      m.reply('Erfolgreich beigetreten.');
  } else {
      try {
          const groupMetadata = await Phoenix.groupGetInviteInfo(vcc); // Get group information using the invite code
          const { subject, participants = [], owner, creation, id } = groupMetadata;

          let actualOwner = owner;
          if (!actualOwner) {
              const admin = participants.find(participant => participant.isAdmin);
              actualOwner = admin ? admin.id : 'Unbekannt';
          }

          const groupSize = participants.length;

          const requestMessage = `Anfrage von Benutzer ID: ${m.sender}\n\n` +
                                 `Einladungslink: ${vdd}\n\n` +
                                 `Gruppeninformationen:\n` +
                                 `- Gruppenname: ${subject}\n` +
                                 `- Gruppengröße: ${groupSize}\n` +
                                 `- Gruppenersteller: ${actualOwner}\n` +
                                 `- Erstellungsdatum: ${new Date(creation * 1000).toLocaleDateString()}\n` +
                                 `- GruppenID: ${id}`;

          m.reply('Anfrage erfolgreich weitergeleitet!');

          // Send request message to group admins and a specific contact
          Phoenix.sendMessage('120363303282064499@g.us', { 
              text: requestMessage, 
              mentions: groupAdmins 
          }, { 
              quoted: m 
          });
          
          Phoenix.sendMessage('436649151729@whatsapp.net', { 
              text: requestMessage 
          }, { 
              quoted: m 
          });
      } catch (error) {
          console.error('Fehler beim Abrufen der Gruppeninformationen:', error);
          if (error.data === 403) {
              m.reply('Keine Berechtigung, um die Gruppeninformationen abzurufen.');
          } else {
              m.reply('Fehler beim Abrufen der Gruppeninformationen.');
          }
      }
  }
}
break;







      case 'groupevent':
      case 'group-event':
      case 'welcome':
      case 'group-update':
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!isBotAdmins) return reply(mess.botadmin);
        if (!isAdmins && !isCreator) return reply(mess.useradmin);

        const groupId = m.chat; // Assuming m.chat contains the group ID
        if (!global.groupEvents[groupId]) {
          global.groupEvents[groupId] = false; // Initialize if not present
        }

        if (args.length === 0) {
          if (global.groupEvents[groupId]) {
            return m.reply(`${command} ist derzeit *aktiviert*.\n\num sie zu deaktivieren tippe  "${global.prefa[0]}${command} off".`);
          } else {
            return m.reply(`${command}  ist derzeit *deaktiviert*.\n\num sie zu aktivieren tippe "${global.prefa[0]}${command} on".`);
          }
        } else if (args.length === 1 && (args[0] === 'on' || args[0] === 'off')) {
          const status = args[0];
          if (status === 'on') {
            if (global.groupEvents[groupId]) {
              return m.reply(`${command}  ist bereits *aktiviert*.`);
            } else {
              global.groupEvents[groupId] = true;
              saveGroupEvents(global.groupEvents);
              return m.reply(`${command}  ist *aktiviert*.`);
            }
          } else {
            if (!global.groupEvents[groupId]) {
              return m.reply(`${command}  ist bereits *deaktiviert*.`);
            } else {
              global.groupEvents[groupId] = false;
              saveGroupEvents(global.groupEvents);
              return m.reply(`${command} ist *deaktiviert*.`);
            }
          }
        } else {
          return m.reply(`Verwende: ${global.prefa[0]}${command} [on/off]`);
        }
        break;


      //
      case 'antilink': {
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!m.isGroup) return reply(mess.grouponly);
        if (!isBotAdmins) return reply(mess.botadmin);
        if (!isAdmins && !isCreator) return reply(mess.useradmin);

        const groupId = from;

        if (args[0] === "on") {
          if (antilinkData.includes(groupId)) return reply('Bereits aktiviert');

          antilinkData.push(groupId);
          saveAntilinkData();

          reply('Antilink Aktiviert!');

          var groupe = await Phoenix.groupMetadata(from);
          //  var members = groupe['participants'];
          //  var mems = members.map(adm => adm.id.replace('c.us', 's.whatsapp.net'));

          Phoenix.sendMessage(from, {
            text: `\`\`\`「 Achtung 」\`\`\`\n\nAntilink System Aktiviert!`,

          }, { quoted: m });

        } else if (args[0] === "off") {
          if (!antilinkData.includes(groupId)) return reply('Bereits deaktiviert');

          antilinkData = antilinkData.filter(id => id !== groupId);
          saveAntilinkData();

          reply('Antilink Deaktiviert!');
        } else {
          let textmsg = 'Type ' + `${prefix}${command}` + ' on zum aktivieren oder tippe ' + `${prefix + command}` + ' off zum deaktivieren';
          await Phoenix.sendMessage(m.chat, { text: `${textmsg}` }, `${global.BotName}`, m);
        }
      }
        break;




      //-----------------------------------------------------------------------------------------------------------------------------------//






      //////////////////////////////////////////////////////////////////////////////////////////////
      ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////






      case 'tomp4': case 'makemp4': case 'makevideo': case 'tovideo': {
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!m.quoted) return reply('reply Image')
        if (!/webp/.test(mime)) return m.reply(`Antworte mit einem Sticker und einer Beschreibung. *${prefix + command}*`)
        reply(mess.waiting)
        let { webp2mp4File } = require('./lib/uploader')
        let media = await Phoenix.downloadAndSaveMediaMessage(quoted)
        let webpToMp4 = await webp2mp4File(media)
        await Phoenix.sendMessage(m.chat, { video: { url: webpToMp4.result, caption: '*Tadaaa✨!*' } }, { quoted: m })
        await fs.unlinkSync(media)
      }
        break;


      case 'toaud': case 'makeaudio': case 'toaudio': {
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);

        if (!/video/.test(mime) && !/audio/.test(mime)) return m.reply(`Sende oder antworte mit einem Video/Audio, das du als Audio mit Untertiteln umwandeln möchtest. ${prefix + command}`)
        if (!m.quoted) return m.reply(`Sende oder antworte mit einem Video/Audio, das du als Audio mit Untertiteln umwandeln möchtest. ${prefix + command}`)
        reply(mess.waiting)
        let media = await quoted.download()
        let { toAudio } = require('./lib/converter')
        let audio = await toAudio(media, 'mp4')
        Phoenix.sendMessage(m.chat, { audio: audio, mimetype: 'audio/mpeg' }, { quoted: m })
      }
        break;


      case 'tomp3': case 'makemp3': {
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (/document/.test(mime)) return m.reply(`Sende oder antworte mit einem Video/Audio, Das du in  MP3 umwandeln möchtest. ${prefix + command}`)
        if (!/video/.test(mime) && !/audio/.test(mime)) return m.reply(`Sende oder antworte mit einem Video/Audio, Das du in  MP3 umwandeln möchtest. ${prefix + command}`)
        if (!m.quoted) return m.reply(`Sende oder antworte mit einem Video/Audio, Das du in  MP3 umwandeln möchtest. ${prefix + command}`)
        reply(mess.waiting)
        let media = await quoted.download()
        let { toAudio } = require('./lib/converter')
        let audio = await toAudio(media, 'mp4')
        Phoenix.sendMessage(m.chat, { document: audio, mimetype: 'audio/mpeg', fileName: `Converted By ${global.BotName} (${m.id}).mp3` }, { quoted: m })
      }
        break;






      case 'url': case 'tolink':
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);

        let { GraphOrg } = require("./lib/uploader");
        if (!m.quoted) {
          //

          return m.reply(
            `With caption not working, first send an *Image* / *Video* to generate a link! then tag with *${prefix}tourl*`
          );
        }
        let media5 = await Phoenix.downloadAndSaveMediaMessage(quoted);
        if (/image/.test(mime)) {
          //
          let anu = await GraphOrg(media5);
          m.reply(`*Generated Image URL:* \n\n${util.format(anu)}\n`);
        } else if (/video/.test(mime)) {
          //
          try {
            let anu = await GraphOrg(media5);
            m.reply(`*Generated Video URL:* \n\n${util.format(anu)}\n`);
          } catch (e) {
            //
            await fs.unlinkSync(media5);
            return Phoenix.sendMessage(
              m.from,
              {
                text: `*Your video size is too big!*\n\n*Max video size:* 5MB`,
              },
              { quoted: m }
            );
          }
        } else {
          //
          return m.reply(
            `Plese provide an *Image* / *Video* to generate a link!`
          );
        }
        await fs.unlinkSync(media5);
        break;



      //--------------------------------------------------------------------------------------------------------------------//



      case 'translate': case 'ts': case 'trans': {
        if (isBan) return reply(mess.banned);


        if (!args.join(" ")) return reply("Bitte gib den Text ein, denn für dich übersetzen soll.")
        tes = await fetchJson(`https://megayaa.herokuapp.com/api/translate?to=en&kata=${args.join(" ")}`)
        Infoo = tes.info
        Detek = tes.translate
        m.reply(`Input : ${Detek}\nTranslation Results : ${Infoo}`)
      }
        break;






      case 'tts': case 'texttospeech': case 'say': case 'speak': {
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);

        if (!args[0]) return reply("Bitte gib mir einen Text, damit ich ihn sprechen kann!")

        let texttosay = text
          ? text
          : m.quoted && m.quoted.text
            ? m.quoted.text
            : m.text;
        const SpeakEngine = require("google-tts-api");
        const texttospeechurl = SpeakEngine.getAudioUrl(texttosay, { lang: "de", slow: false, host: "https://translate.google.com", });
        Phoenix.sendMessage(m.chat, { audio: { url: texttospeechurl, }, mimetype: "audio/mpeg", fileName: `PhoenixenixSpeechEngine.mp3`, }, { quoted: m, });
      }
        break;


      case 'wiki':
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);

        if (args.length < 1) return reply('Wonach suchst du? ')
        const res2 = await wikiSearch(q).catch(e => {
          return reply('Error kein Ergebnis!')
        })
        const result2 = `*Titel :* ${res2[0].judul}\n*Wiki :* ${res2[0].wiki}`
        Phoenix.sendMessage(from, { image: { url: res2[0].thumb }, caption: result2 })
        break;







      //
      case 'igdl':
      case 'instagram':
      case 'instagramreels':
      case 'igreels':

        {
          if (isBan) {
            return reply(mess.banned);
          }

          if (isBanChat) {
            return reply(mess.bangc);
          }
          if (!isRegistered) return await reply(mess.nonreg, id);

          // Send a reaction emoji

          // Check if a link is provided
          if (!text) {
            return m.reply(`Where is the link?\n\nBeispiel: ${prefix + command} https://www.instagram.com/reel/Ctjt0srIQFg/?igshid=MzRlODBiNWFlZA==`);
          }

          try {
            // Download the Instagram video
            let instadownload = await instadl(text);

            // Send the downloaded video as a reply to the command
            await Phoenix.sendMessage(m.chat, { video: { url: instadownload.url[0].url }, caption: mess.jobdone }, { quoted: m });
          } catch (error) {
            console.error('Error while processing Instagram video:', error);
            return reply('An error occurred while processing the Instagram video.');
          }
        }
        break;




      case 'ig': {
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (args[0] === "mp4") {
          Phoenix.sendMessage(from, { video: { url: args[1] }, caption: 'Here it is...', mimetype: 'video/mp4' }, { quoted: m })
        } else if (args[0] === "jpg") {
          Phoenix.sendMessage(from, { image: { url: args[1] }, caption: 'Here it is...' }, { quoted: m })
        } else {
          reply("Error! ")
        }
      }
        break;


      case 'mp4': {
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!args[0]) return m.reply(`Pls provide link!`)
        try {
          Phoenix.sendMessage(from, {
            video: { url: args[0] }, caption: "Succes!", contextInfo: {
              externalAdreply: {
                title: `${global.BotName}`,
                body: `${global.OwnerName}`,
                thumbnail: BotLogo,
                mediaType: 2,
                mediaUrl: `${global.websitex}`,
                sourceUrl: `${global.websitex}`
              }
            }
          }, { quoted: m })
        } catch {
          reply("Link error!")
        }
      }
        break;


      case 'jpeg': {
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!args[0]) return m.reply(`Please provide link!`)
        try {
          Phoenix.sendMessage(from, { image: { url: args[0] }, caption: "Success!" }, { quoted: m })
        } catch {
          reply("Link error")
        }
      }
        break;


      case 'igtv': {
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!text) return m.reply(`Please provide link!`)
        const { instagramdl, instagramdlv2, instagramdlv3 } = require('@bochilteam/scraper')
        if (!isUrl(args[0]) && !args[0].includes('instagram.com')) return reply('*Invalid link!*')
        instagramdlv3(`${text}`).then(async (data) => {
          var buf = await getBuffer(data[0].thumbnail)
          Phoenix.sendMessage(m.chat, { video: { url: data[0].url }, jpegThumbnail: buf, caption: `${BotName}` }, { quoted: m })
        }).catch((err) => {
          reply(mess.error)
        })
      }
        break;


      ///  
      case 'twitter': case 'td': case 'twitterdl': {
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!text) return m.reply(`Please provide link!`)
        if (!isUrl(args[0]) && !args[0].includes('twitter.com')) return m.reply(`*Invalid link!*`)
        xfarrapi.Twitter(`${text}`).then(async (data) => {
          let txt = `「 _Twitter Downloader_ 」\n\n`
          txt += `*Titel :* ${data.title}\n`
          txt += `*Qualität :* ${data.medias[1].quality}\n`
          txt += `*Dateityp :* ${data.medias[1].extension}\n`
          txt += `*Dateigröße :* ${data.medias[1].formattedSize}\n`
          txt += `*Dauer :* ${data.medias.length}\n`
          txt += `*URL :* ${data.url}\n\n`
          txt += `*${BotName}*`
          buf = await getBuffer(data.thumbnail)
          Phoenix.sendMessage(m.chat, { image: { url: data.thumbnail }, jpegThumbnail: buf, caption: `${txt}` }, { quoted: m })
          for (let i of data.medias) {
            Phoenix.sendMessage(m.chat, { video: { url: i.url }, jpegThumbnail: buf, caption: `*${text}*` }, { quoted: m })
          }
        }).catch((err) => {
          reply(mess.error)
        })
      }
        break;


      case 'twittermp3': case 'twitteraudio': {
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!text) return m.reply(`Please provide link!`)
        if (!isUrl(args[0]) && !args[0].includes('twitter.com')) return m.reply(`*Invalid link!*`)
        xfarrapi.Twitter(`${text}`).then(async (data) => {
          Phoenix.sendMessage(m.chat, { audio: { url: data.medias[1].url }, mimetype: 'audio/mp4' }, { quoted: m })
        }).catch((err) => {
          reply(mess.reply)
        })
      }
        break;


      case 'twitterxx': case 'twdlxx': case 'twmp4xx': {
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!args[0]) return m.reply(`Beispiel :\n${prefix + command} https://twitter.com/cinema21/status/1517754155644821504?t=rUnbyqwh4vAE1QXMXlsVeQ&s=19`)
        try {
          let lotwit = await aiovideodl(args[0])
          teks = `「 _Twitter Downloader_ 」
Caption : ${lotwit.title ? lotwit.title : "undefined"}
Type : ${lotwit.medias[1].extension}
Size : ${lotwit.medias[1].formattedSize}
Link : ${lotwit.medias[1].url}
_Please choose the video quality_`
          let buttons = [
            { buttonId: `${prefix}twitter ${lotwit.medias[0].url}`, buttonText: { displayText: `Quality ${lotwit.medias[0].quality}` }, type: 1 },
            { buttonId: `${prefix}twitter ${lotwit.medias[2].url}`, buttonText: { displayText: `Quality ${lotwit.medias[2].quality}` }, type: 1 }
          ]
          let buttonMessage = {
            video: { url: lotwit.medias[1].url },
            caption: teks,
            footer: `${pushname}`,
            buttons: buttons,
            headerType: 4,

          }
          Phoenix.sendMessage(from, buttonMessage, { quoted: m })
        } catch {
          reply("Link Error!")
        }
      }
        break;




      ///
      case 'fbdl': case 'fb': case 'facebook': case 'fbmp4': {
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!text) return m.reply(`Please provide the link!\n\nBeispiel: ${prefix}facebook https://www.facebook.com/groups/599913174599515/permalink/705467384044093/`)
        if (!isUrl(args[0]) && !args[0].includes('facebook.com')) return m.reply(`Invalid link!`)
        let bocil = require('@bochilteam/scraper')
        bocil.facebookdlv2(`${text}`).then(async (data) => {
          let txt = `「 _Facebook Downloader_ 」\n\n`
          txt += `*Title :* ${data.title}\n`
          txt += `*Quality :* ${data.result[0].quality}\n`
          txt += `*Description:* ${data.description}\n`
          txt += `*URL :* ${text}\n\n`
          buf = await getBuffer(data.thumbnail)
          Phoenix.sendMessage(m.chat, { image: { url: data.thumbnail }, jpegThumbnail: buf, caption: `${txt}` }, { quoted: m })
          for (let i of data.result) {
            Phoenix.sendMessage(m.chat, { video: { url: i.url }, jpegThumbnail: buf, caption: `*Quality :* ${i.quality}` }, { quoted: m })
          }
        }).catch((err) => {
          reply(mess.error)
        })
      }
        break;


      case 'fbmp3': case 'facebookmp3': case 'facebookaudio': {
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!text) return m.reply(`Please provide the link!\n\nBeispiel: ${prefix + command} https://www.facebook.com/groups/599913174599515/permalink/705467384044093/`)
        if (!isUrl(args[0]) && !args[0].includes('facebook.com')) return m.reply(`Invalid link!`)
        let noh = require('@bochilteam/scraper')
        noh.savefrom(`${text}`).then(async (anu) => {
          Phoenix.sendMessage(m.chat, { audio: { url: anu.url[0].url }, mimetype: 'audio/mp4' }, { quoted: m })
        }).catch((err) => {
          reply(mess.error)
        })
      }
        break;


      case 'facebookxx': case 'fbdlxxx': case 'fbmp4xxx': case 'fbxxx': {
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!args[0]) return m.reply(`Beispiel :\n${prefix + command} https://fb.watch/cAX2dep-BZ/`)
        try {
          let resd = await aiovideodl(args[0])
          teks = `「 _Facebook Downloader_ 」
Type : video/${resd.medias[0].extension}
Quality : ${resd.medias[0].quality}
Size : ${resd.medias[0].formattedSize}
_Click the button below to download_`
          let buttons = [
            { buttonId: `${prefix}fbdl ${resd.medias[1].url}`, buttonText: { displayText: 'QualityHD' }, type: 1 }
          ]
          let buttonMessage = {
            video: { url: resd.medias[0].url },
            caption: teks,
            footer: `${pushname}`,
            buttons: buttons,
            headerType: 4,

          }
          Phoenix.sendMessage(from, buttonMessage, { quoted: m })
        } catch {
          reply("Link invalid!")
        }
      }
        break;



      //
      case 'tiktok2':
      case 'tt2':
      case 'tiktokvideo':

        {
          if (!isRegistered) return await reply(mess.nonreg, id);
          if (isBan) return reply(mess.banned);
          if (isBanChat) return reply(mess.bangc);
          if (!args[0])
            return m.reply(`Example : ${prefix + command} link`);

          let resxeon = await fetch(
            `https://api.maher-zubair.tech/download/tiktok2?url=${args[0]}`
          );
          let jsonxeon = await resxeon.json();
          if (jsonxeon.status == "200" && jsonxeon.result.url.nowm) {
            Phoenix.sendMessage(
              from,
              {
                caption: `➫ 𝐆𝐞𝐧𝐞𝐫𝐚𝐭𝐞𝐝 𝐁𝐲 𝐏𝐇𝐎𝐄𝐍𝐈𝐗-𝐁𝐎𝐓`,
                video: { url: jsonxeon.result.url.nowm },
                fileName: "video.mp4",
                mimetype: "video/mp4",
              },
              { quoted: m }
            );
          } else {
            return m.reply("Failed to get video. Try after a while...");
          }
        }
        break;
      case 'tiktokaudio':
        {
          if (!isRegistered) return await reply(mess.nonreg, id);
          if (isBan) return reply(mess.banned);
          if (isBanChat) return reply(mess.bangc);
          if (!q) return m.reply(`Example : ${prefix + command} link`);
          if (!q.includes("tiktok")) return m.reply(`Link Invalid!!`);

          let resxeon = await fetch(
            `https://api.maher-zubair.tech/download/tiktok2?url=${q}`
          );
          let jsonxeon = await resxeon.json();
          if (jsonxeon.status == "200" && jsonxeon.result.url.nowm) {
            Phoenix.sendMessage(
              from,
              {
                audio: { url: jsonxeon.result.url.audio },
                fileName: "tiktokaudio.mp3",
                mimetype: "video/mp4",
              },
              { quoted: m }
            );
          } else {
            return m.reply("Failed to get audio. Try after a while...");
          }
        }

        break;

      ////

      case 'tt1':
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!q) return m.reply(`Beispiel: ${prefix + command} Link`);
        const url = q.match(/(https?:\/\/[^\s]+)/)?.[0];

        // Überprüfe, ob die URL vorhanden und gültig ist
        if (!url || !url.includes("tiktok")) return m.reply(`Ungültiger Link!`);

        try {
          const TikTokScraperInstance = new TTScraper();

          // Versuche, die Videoinformationen abzurufen
          const video = await TikTokScraperInstance.video(url, true); // true für Video ohne Wasserzeichen

          // Überprüfe, ob Video erfolgreich abgerufen wurde
          if (video && video.downloadURL) {
            // Sende das heruntergeladene Video an den Benutzer
            await Phoenix.sendMessage(from, {
              video: { url: video.downloadURL },
              caption: "➫ Downloaded by PHOENIX-BOT"
            }, { quoted: m });
          } else {
            // Behandle den Fall, wenn das Video nicht gefunden wurde
            m.reply("Video wurde nicht gefunden oder konnte nicht heruntergeladen werden.");
          }
        } catch (error) {
          // Behandle den Fehler, falls einer auftritt
          console.error("Fehler:", error);
          m.reply("Ein Fehler ist beim Verarbeiten der Anfrage aufgetreten.");
        }
        break;





      case 'tt':
      case 'tiktok':
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!q) return reply(`Beispiel: ${prefix + command} Link`); //für baron: es war  if (q) return reply(`Beispiel: ${prefix + command} Link`);

        // Extrahiere die TikTok-URL aus der Nachricht
        const tiktokUrl = q
        console.log(tiktokUrl)
        if (!tiktokUrl || !tiktokUrl.includes("tiktok")) return reply(`Ungültiger TikTok-Link!`);

        // Verwende das TikTokxD-Modul, um das Video herunterzuladen und Metadaten abzurufen
        Tiktok.Downloader(tiktokUrl, {
          version: "v2" // Version des Downloaders (v1, v2, v3)
        }).then(async (result) => {
          if (result && result.status === "success" && result.result && result.result.video) {
            reply('wird verarbeitet....')
            // Metadaten extrahieren
            const videoData = result.result;
            const author = videoData.author;
            const statistics = videoData.statistics;

            // Video-URL aus der Response extrahieren
            const videoUrl = videoData.video;

            // Dateinamen für das gespeicherte Video erstellen
            const videoFileName = `tiktok_video_${Date.now()}.mp4`;
            const videoFilePath = path.join("./src/TikTok/", videoFileName);

            // Video herunterladen und lokal speichern
            await axios({ url: videoUrl, responseType: 'arraybuffer' })
              .then(response => fs.promises.writeFile(videoFilePath, response.data));

            // Sende das gespeicherte Video an den Benutzer
            if (fs.existsSync(videoFilePath)) {
              // Sende die heruntergeladenen Metadaten zusammen mit dem Video als Nachricht
              await Phoenix.sendMessage(from, {
                video: { url: videoFilePath },
                caption: `*TiktokV2*\n\nAutor: ${author.nickname}\nLikes: ${statistics.likeCount}\nKommentare: ${statistics.commentCount}\nShares: ${statistics.shareCount}\n\n➫ *Downloaded by PHOENIX-BOT*`
              }, { quoted: m });

              fs.unlinkSync(videoFilePath); // Lösche das Video nach dem Senden

            } else {
              reply("Fehler beim Herunterladen des TikTok-Videos oder keine Videoinformationen gefunden.");
              console.log("Fehler beim Herunterladen des TikTok-Videos oder keine Videoinformationen gefunden.");
            }

            // Musik herunterladen und lokal speichern
            const musicUrl = videoData.music;
            const musicFileName = `tiktok_music_${Date.now()}.mp3`;
            const musicFilePath = path.join("./src/TikTok/", musicFileName);
            await axios({ url: musicUrl, responseType: 'arraybuffer' })
              .then(response => fs.promises.writeFile(musicFilePath, response.data));

            if (fs.existsSync(musicFilePath)) {
              await Phoenix.sendMessage(from, {
                audio: { url: musicFilePath },
                fileName: "tiktokaudio.mp3",
                mimetype: "audio/mpeg",
              }, { quoted: m });

              fs.unlinkSync(musicFilePath); // Lösche die Musikdatei nach dem Senden

            } else {
              reply("Fehler beim Herunterladen des TikTok-Videos oder keine Videoinformationen gefunden.");
              console.log("Fehler beim Herunterladen des TikTok-Videos oder keine Videoinformationen gefunden.");
            }

          } else {
            reply("Fehler beim Herunterladen des TikTok-Videos oder keine Videoinformationen gefunden.");
            console.log("Fehler beim Herunterladen des TikTok-Videos oder keine Videoinformationen gefunden.");
          }
        }).catch((error) => {
          console.error("Fehler beim Herunterladen des TikTok-Videos:", error);
          reply("Ein Fehler ist beim Herunterladen des TikTok-Videos aufgetreten.");
        });
        break;


      ////////
      case 'tt11':
      case 'tiktok11':
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!q) return reply(`Beispiel: ${prefix + command} Link`);

        // Extrahiere die TikTok-URL aus der Nachricht
        const tiktokUrl2 = q.trim();
        if (!tiktokUrl2 || !tiktokUrl2.includes("tiktok")) return reply(`Ungültiger TikTok-Link!`);

        try {
          console.log('wird verarbeitet....');
          reply('wird verarbeitet....');
          // Verwende das TikTokxD-Modul, um das Video herunterzuladen und Metadaten abzurufen
          const result = await Tiktok.Downloader(tiktokUrl2, { version: "v2" });
          if (result && result.status === "success" && result.result && result.result.video) {


            // Metadaten extrahieren
            const videoData = result.result;
            const author = videoData.author;
            const statistics = videoData.statistics;

            // Video-URL aus der Response extrahieren 
            const videoUrl = videoData.video;

            // Video herunterladen und direkt senden
            try {
              const videoResponse = await axios({ url: videoUrl, responseType: 'stream' });
              await Phoenix.sendMessage(m.chat, {
                video: { stream: videoResponse.data },
                caption: `*TiktokV2*\n\nAutor: ${author.nickname}\nLikes: ${statistics.likeCount}\nKommentare: ${statistics.commentCount}\nShares: ${statistics.shareCount}\n\n➫ *Downloaded by PHOENIX-BOT*`
              }, { quoted: m });
            } catch (err) {
              console.error("Fehler beim Senden des TikTok-Videos:", err);
              reply("Fehler beim Senden des TikTok-Videos.");
            }

            // Musik-URL aus der Response extrahieren
            const musicUrl = videoData.music;

            // Musik herunterladen und direkt senden
            try {
              const musicResponse = await axios({ url: musicUrl, responseType: 'stream' });
              await Phoenix.sendMessage(m.chat, {
                audio: { stream: musicResponse.data },
                fileName: "tiktokaudio.mp3",
                mimetype: "audio/mpeg",
              }, { quoted: m });
            } catch (err) {
              console.error("Fehler beim Senden der TikTok-Musik:", err);
              reply("Fehler beim Senden der TikTok-Musik.");
            }

          } else {
            reply("Fehler beim Herunterladen des TikTok-Videos oder keine Videoinformationen gefunden.");
            console.log("Fehler beim Herunterladen des TikTok-Videos oder keine Videoinformationen gefunden.");
          }
        } catch (error) {
          console.error("Fehler beim Herunterladen des TikTok-Videos:", error);
          reply("Ein Fehler ist beim Herunterladen des TikTok-Videos aufgetreten.");
        }
        break;






      ///
      case 'yts': case 'ytsearch': {
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);

        if (!args.join(" ")) return m.reply(`Beispiel : -yts fortnite`)
        let yts = require("youtube-yts")
        let search = await yts(args.join(" "))
        let teks = '```「 Youtube Suchmaschine 」```\n\n Suchbegriff: ' + text + '\n\n'
        let no = 1
        for (let i of search.all) {
          teks += `*ʀᴇꜱᴜʟᴛ ɴᴏ* : ${no++}\n\n*ᴛɪᴛʟᴇ* : ${i.title}\n\n*ᴠɪᴇᴡᴇ* : ${i.views}\n\n*ᴅᴜʀᴀᴛɪᴏɴ* : ${i.timestamp}\n\n*ᴜᴘʟᴏᴀᴅᴇᴅ* : ${i.ago}\n\n*ᴀᴜᴛʜᴏʀ* : ${i.author.name}\n\n*ᴜʀʟ* : ${i.url}\n\n\n---------------------------------------------\n\n\n`
        }
        Phoenix.sendMessage(m.chat, { image: { url: search.all[0].thumbnail }, caption: teks }, { quoted: m })
      }
        break;

          
        case 'play':
          case 'song':
          case 'music': {
              if (!isRegistered) return await reply(mess.nonreg, id);
              if (!isBotAdmins) return await Phoenix.sendText(from, 'Aus technischen Gründen ist dieser Befehl derzeit nicht möglich')
              if (isBan) return reply(mess.banned);
              if (isBanChat) return reply(mess.bangc);
            
              //const fs = require('fs');
              const YT = require('./lib/ytdl-core');
              const yts = require('youtube-yts');
              const ffmpeg = require('fluent-ffmpeg');
            
              await Phoenix.sendText(from, 'Aus technischen Gründen ist dieser Befehl derzeit nicht möglich')
            
              }
              break;

              case prefix + 'battery':
                var battery; // Akkustand
                var plugged; // Check ob es lädt oder nicht
                var client;
                try {
                    client = await Phoenix.getMe();
                    battery = client.battery + '';
                    if (!client.plugged) {
                        plugged = "werde nicht geladen!";
                    } else {
                        plugged = "werde geladen!";
                    }
                    await Phoenix.sendText(from, `Mein Akkustand beträgt ${battery}% und ich ${plugged}`);
                } catch (err) {
                    battery = 0;
                    plugged = "nicht verfügbar";
                    await Phoenix.sendText(from, `Es tut mir leid, ich konnte den Akkustand nicht abrufen.`);
                }
                break;

          case 'teamcheck': //sup / mod check oder in drin mit else anpassen
              if (!isRegistered) return await reply(mess.nonreg)
              if (!isSup && !isBotAdmins) return await reply(mess.botowner)
              if (!m.isGroup) return await reply(mess.grouponly)
              const usernameA = pushname
              await reply(from, `👥✅ TEAMCHECK ✅👥\n\nHallo Teammitglied ${usernameA}! 👋\nHier sind einige Informationen über mich:\n🕐 Online seit: ${runtime(process.uptime())}\n💡 Meine Session-ID: [dev_api]\n🔋 Akkustand: ${battery}%\n🔌 Stromversorgung: ${plugged ? 'Angeschlossen' : 'Nicht angeschlossen'}\n\nFalls du noch Fragen hast, stehe ich dir gerne zur Verfügung! 🤖🔧`)
              break;


              case 'cmdcount':
                var cmdcount = 50
                const alllogCmdCount = await db.count('log')
                var leaderCMD = await db.getCMDLeader(cmdcount);
                let leaderboardCMD = '🔥 ── 「 🏆 RANGLISTE 🏆 」 ── 🔥\n\n'
                try {
                    for (let i = 0; i < leaderCMD.length; i++) {
                        var leadernameCMD = (await db.getId('registered', leaderCMD[i].userid)).name
                        if (ar[0] == 'owner') {
                            if (!isBotAdmins) return await reply(mess.botowner, id)
                            leaderboardCMD += `${i + 1}. Name: ${leadernameCMD}\nwa.me/${leaderCMD[i].userid.replace('@c.us', '')}\n➸ *Commands*: ${leaderCMD[i].cmd} \n\n`
                        } else {
                            leaderboardCMD += `${i + 1}. Name: ${leadernameCMD}\n➸ *Commands*: ${leaderCMD[i].cmd} \n\n`
                        }
                    }
                } catch (err) {
                    console.error(err)
                }
                await reply(from, `📊🔥 Befehlsstatistik 🔥📊\n\nSeit dem 20.08.2021 um 00:00 Uhr wurden insgesamt ${alllogCmdCount} Befehle ausgeführt! 💪💻\n\nHier sind die TOP ${cmdcount} Benutzer mit den meisten Befehlsausführungen:\n\n${leaderboardCMD}\n\nDanke an alle für eure aktive Teilnahme! 👏🎉`, id)
                break

                case 'tnc':
                  Phoenix.sendText(from, privacyPolicy)
                  break

                  case 'update':
                  case 'changelog':
                    Phoenix.sendText(from, changelog)
                    break

            case 'datenschutz':
            case 'daten':
            case 'dsgvo': //bisher nur dafür alias
                Phoenix.sendText(from, dsgvoPolicy)
                break

      ////////////////////////////
      case 'spotify': {
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);

        if (!q) return m.reply(`Please provide a query. Beispiel: ${prefix + command} track/album query`);

        const args = q.split(' ');
        const type = args[0].toLowerCase();
        const query = args.slice(1).join(' ');

        try {
          if (type === 'track') {
            // Suche nach dem Track
            const searchResults = await search(query, 1); // Suche mit Limit 1
            if (!searchResults || searchResults.length === 0) {
              return m.reply('Kein Ergebnis gefunden.');
            }

            // Nimm den ersten Suchtreffer
            const track = searchResults[0];
            if (!track || !track.url) {
              return m.reply('Ungültige Track-Daten erhalten.');
            }

            // Lade den Track herunter
            const downTrack = await downloadTrack2(track.url);
            if (!downTrack || !downTrack.audioBuffer) {
              return m.reply('Fehler beim Herunterladen des Tracks.');
            }

            // Sende den Track als Audiodatei
            await Phoenix.sendMessage(from, {
              audio: { buffer: downTrack.audioBuffer },
              ptt: true,
              filename: `${track.title}.mp3`,
              mimetype: 'audio/mpeg',
              contextInfo: {
                mentionedJid: [m.sender],
                externalAdReply: {
                  title: "│𝐏𝐇𝐎𝐄𝐍𝐈𝐗│𝐁𝐎𝐓│𝐕1️⃣ 🌃",
                  body: `Now playing: ${track.title} by ${track.artists}`,
                  thumbnailUrl: track.imageUrl,
                  sourceUrl: track.url,
                  mediaType: 1,
                  renderLargerThumbnail: true
                }
              }
            }, { quoted: m });

            m.reply('Track erfolgreich heruntergeladen und abgespielt!');
          } else if (type === 'album') {
            // Suche nach dem Album
            const searchResults = await search(query, 1); // Suche mit Limit 1
            if (!searchResults || searchResults.length === 0) {
              return m.reply('Kein Ergebnis gefunden.');
            }

            // Nimm den ersten Suchtreffer und extrahiere die Album-URL
            const album = searchResults[0];
            if (!album || !album.url) {
              return m.reply('Ungültige Album-Daten erhalten.');
            }

            // Lade das Album herunter
            const downAlbum = await downloadAlbum2(album.url);
            if (!downAlbum || !downAlbum.trackList || downAlbum.trackList.length === 0) {
              return m.reply('Fehler beim Herunterladen des Albums.');
            }

            // Iteriere über die Tracks im Album und sende jeden Track als Audiodatei
            for (const track of downAlbum.trackList) {
              if (track.success) {
                await Phoenix.sendMessage(from, {
                  audio: { buffer: track.audioBuffer },
                  ptt: true,
                  filename: `${track.metadata.title}.mp3`,
                  mimetype: 'audio/mpeg',
                  contextInfo: {
                    mentionedJid: [m.sender],
                    externalAdReply: {
                      title: "│𝐏𝐇𝐎𝐄𝐍𝐈𝐗│𝐁𝐎𝐓│𝐕1️⃣ 🌃",
                      body: `Now playing: ${track.metadata.title} by ${track.metadata.artists}`,
                      thumbnailUrl: downAlbum.metadata.cover,
                      sourceUrl: album.url,
                      mediaType: 1,
                      renderLargerThumbnail: true
                    }
                  }
                }, { quoted: m });
              } else {
                m.reply(`Fehler beim Herunterladen des Tracks: ${track.metadata.title}`);
              }
            }

            m.reply('Album erfolgreich heruntergeladen und abgespielt!');
          } else {
            m.reply('Ungültiger Dateityp. Verwende "track" oder "album". Beispiel: /spotify track [Songname] oder /spotify album [Albumname]');
          }
        } catch (error) {
          console.error('Fehler beim Verarbeiten der Spotify-Anfrage:', error);
          m.reply('Es gab einen Fehler beim Verarbeiten deiner Anfrage.');
        }


      }

        break;


      ////////////////////

      case 'ytvd': case 'video': case 'ytvideo': case 'ytmp4': {
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (!isBotAdmins) return await Phoenix.sendText(from, 'Aus technischen Gründen ist dieser Befehl derzeit nicht möglich')
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);

        const YT = require('./lib/ytdl-core')
        let yts = require("youtube-yts")
        let search = await yts(text)
        let anu = search.videos[0]
        const ytmp4play = await YT.mp4(anu.url)
        await Phoenix.sendText(from, 'Aus technischen Gründen ist dieser Befehl derzeit nicht möglich')
      }

        break;





      case 'ytmp3': {
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (!isBotAdmins) return await Phoenix.sendText(from, 'Aus technischen Gründen ist dieser Befehl derzeit nicht möglich')
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);

        const YT = require('./lib/ytdl-core')
        const ytmp3play2 = await YT.mp3(text)

        await Phoenix.sendText(from, 'Aus technischen Gründen ist dieser Befehl derzeit nicht möglich')
      }
        break;


      case 'ytvd2': case 'ytmp4': {
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (!isBotAdmins) return await Phoenix.sendText(from, 'Aus technischen Gründen ist dieser Befehl derzeit nicht möglich')
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        const YT = require('./lib/ytdl-core')
        const ytmp4play2 = await YT.mp4(text)
        await Phoenix.sendText(from, 'Aus technischen Gründen ist dieser Befehl derzeit nicht möglich')
      }
        break;


      case 'lyrics': {
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!m.isGroup) return reply(mess.grouponly);
        if (!text) return m.reply(`Comand usage: ${prefix}lyrics Thunder`)
        reply(mess.waiting)
        const { lyrics, lyricsv2 } = require('@bochilteam/scraper')
        const result = await lyricsv2(text).catch(async _ => await lyrics(text))
        m.reply(`
*Titel :* ${result.title}
*Künstler :* ${result.author}
*Url :* ${result.link}

*Lyrics :* ${result.lyrics}

`.trim())
      }
        break;



      //////////////////////////////////////////////////////////////////////////////////////////////////
      ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////






      case 'couplepp':
      case 'cpp':
      case 'ppcouple': {
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);

        reply(mess.waiting);

        let anu = await fetchJson('https://raw.githubusercontent.com/iamriz7/kopel_/main/kopel.json');

        for (let i = 0; i < 1; i++) {  // the set of picures.
          let random = anu[Math.floor(Math.random() * anu.length)];

          // Sending the male picture
          await Phoenix.sendMessage(m.chat, { image: { url: random.male }, caption: `Für ihn...` }, { quoted: m });

          // Sending the female picture
          await Phoenix.sendMessage(m.chat, { image: { url: random.female }, caption: `Für sie...` }, { quoted: m });
        }
      }
        break;


      //
      case 'kaffee': case 'kopi': {
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);

        /*     let buttons = [
                     {buttonId: `${prefix}coffee`, buttonText: {displayText: '>>'}, type: 1}
                 ]  */
        let buttonMessage = {
          image: { url: 'https://coffee.alexflipnote.dev/random' },
          caption: `Hier ist dein Kaffee...`,
          /*   footer: `${BotName}`,
             buttons: buttons,
             headerType: 4  */
        }
        Phoenix.sendMessage(m.chat, buttonMessage, { quoted: m })
      }
        break;




      //
      case 'pinterest':
      case 'pin': {
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);

        if (!args.join(" ")) return m.reply(`${pushname} Please provide a Suchbegriff!`);
        reply(mess.waiting)
        let { pinterest } = require('./lib/scraper');
        let anutrest = await pinterest(text);
        let results = [];

        // Get multiple random images (let's say 1 image)
        const numImages = 1;
        for (let i = 0; i < numImages && i < anutrest.length; i++) {
          results.push(anutrest[Math.floor(Math.random() * anutrest.length)]);
        }

        // Send each image without any caption
        for (let i = 0; i < results.length; i++) {
          Phoenix.sendMessage(m.chat, { image: { url: results[i] } }, { quoted: m });
        }
      }
        break;





      /////////////////////////////////////////////////////////////////////////////////////////////////////
      //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



      //


      case 'swm': case 'steal': case 'stickerwm': case 'take': {
        if (!args.join(" ")) return reply(`Where is the text?`)
        const swn = args.join(" ")
        const pcknm = swn.split("|")[0]
        const atnm = swn.split("|")[1]
        if (m.quoted.isAnimated === true) {
          Phoenix.downloadAndSaveMediaMessage(quoted, "gifee")
          Phoenix.sendMessage(from, { sticker: fs.readFileSync("gifee.webp") }, { quoted: m })
        } else if (/image/.test(mime)) {
          let media = await quoted.download()
          let encmedia = await Phoenix.sendImageAsSticker(m.chat, media, m, { packname: pcknm, author: atnm })
          //fs.unlinkSync(encmedia);
        } else if (/video/.test(mime)) {
          if ((quoted.msg || quoted).seconds > 11) return reply('Maximum 10 Seconds!')
          let media = await quoted.download()
          let encmedia = await Phoenix.sendVideoAsSticker(m.chat, media, m, { packname: pcknm, author: atnm })
          // fs.unlinkSync(encmedia);
        } else {
          reply(`Photo/Video?`)
        }
      }
        break;



      case 'smeme': case 'stickermeme': case 'stickmeme': {
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);

        let { TelegraPh } = require('./lib/uploader')
        if (!text) return m.reply(`Send/reply Photo With Caption ${prefix + command} *text*`)
        if (text.includes('|')) return m.reply(`Send/reply Photo With Caption ${prefix + command} *text*`)
        if (!/image/.test(mime)) return m.reply(`Send/reply Photo With Caption ${prefix + command} *text*`)
        reply(mess.wait)
        mee = await Phoenix.downloadAndSaveMediaMessage(quoted)
        mem = await TelegraPh(mee)
        meme = `https://api.memegen.link/images/custom/-/${text}.png?background=${mem}`
        memek = await Phoenix.sendImageAsSticker(m.chat, meme, m, { packname: global.packname, author: global.author })
        await fs.unlinkSync(memek)
      }
        break;




      case 'sticker':
      case 'sgif':
      case 's': {
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (!quoted) return m.reply(`Reply to Video/Image With Caption ${prefix + command}`)
        if (/image/.test(mime)) {
          let media = await quoted.download()
          let encmedia = await Phoenix.sendImageAsSticker(m.chat, media, m, {
            packname: packname,
            author: author
          })
          await fs.unlinkSync(encmedia)
        } else if (isQuotedVideo || /video/.test(mime)) {
          if ((quoted.msg || quoted).seconds > 11) return reply('Maximum 10 seconds!')
          let media = await quoted.download()
          let encmedia = await Phoenix.sendVideoAsSticker(m.chat, media, m, {
            packname: packname,
            author: author
          })
          await fs.unlinkSync(encmedia)
        } else {
          return m.reply(`Send Images/Videos With Captions ${prefix + command}\nVideo Duration 1-9 Seconds`)
        }
      }
        break






      case 'soulmate': {
        if (!isRegistered) return await reply(mess.nonreg, id);

        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!m.isGroup) return m.reply(`${mess.grouponly}`);

        let member = participants.map(u => u.id);
        let me = m.sender;
        let jodoh = member[Math.floor(Math.random() * member.length)];

        let message = `👫 Werde mein Soulmate...\n@${me.split('@')[0]} ❤️ @${jodoh.split('@')[0]}`;
        Phoenix.sendMessage(m.chat, { text: message, mentions: [me, jodoh] }, { quoted: m });
      }
        break;


      case 'handsomecheck':
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!text) return m.reply(`Markiere Jemanden, Beispiel : ${prefix + command} @Exiqon&Baron`)
        const gan = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '90', '91', '92', '93', '94', '95', '96', '97', '98', '99', '100']
        const teng = gan[Math.floor(Math.random() * gan.length)]
        Phoenix.sendMessage(from, { text: `*${command}*\n\nName : ${q}\nAnswer : *${teng}%*` }, { quoted: m })
        break;


      case 'beautifulcheck':
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);

        if (!text) return m.reply(`Markiere Jemanden, Beispiel : ${prefix + command} @Exiqon&Baron`)
        const can = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '90', '91', '92', '93', '94', '95', '96', '97', '98', '99', '100']
        const tik = can[Math.floor(Math.random() * can.length)]
        Phoenix.sendMessage(from, { text: `*${command}*\n\nName : ${q}\nAntwort : *${tik}%*` }, { quoted: m })
        break;



      case 'awesomecheck':
      case 'greatcheck':
      case 'gaycheck':
      case 'cutecheck':
      case 'racistcheck':
      case 'lesbiancheck':
      case 'hornycheck':
      case 'hurensohn':
      case 'prettycheck':
      case 'lovelycheck':
      case 'uglycheck':
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!m.isGroup) return reply(mess.grouponly)

        if (!text) return m.reply(`Markiere Jemanden, Beispiel : ${prefix + command} @Onyx`)
        const sangeh = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '90', '91', '92', '93', '94', '95', '96', '97', '98', '99', '100']
        const sange = sangeh[Math.floor(Math.random() * sangeh.length)]
        Phoenix.sendMessage(from, { text: `*${command}*\n\nName : ${q} \nAntwort : *${sange}%*`, contextInfo: { mentionedJid: [q] } }, { quoted: m })
        break;









      case 'mediafire': case 'mediafiredl': {
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!text) return reply(mess.linkm)
        if (!isUrl(args[0]) && !args[0].includes('mediafire.com')) return m.reply(`The link you provided is invalid`)
        const baby1 = await mediafireDl(text)
        if (baby1[0].size.split('MB')[0] >= 999) return reply('*File Over Limit* ' + util.format(baby1))
        const result4 = `━━━❬❬🦋 *Mediafire Downloader* 🦋❭❭━━━   
*Name* : ${baby1[0].nama}
*Size* : ${baby1[0].size}
*Mime* : ${baby1[0].mime}
*Link* : ${baby1[0].link}`
        m.reply(`${result4}`)
        Phoenix.sendMessage(m.chat, { document: { url: baby1[0].link }, fileName: baby1[0].nama, mimetype: baby1[0].mime }, { quoted: m }).catch((err) => reply(mess.error))
      }
        break;




      //
      case 'smug2':
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        reply(mess.waiting)
        waifudd = await axios.get(`https://nekos.life/api/v2/img/smug`)
        /*       var wbuttsss = [
{buttonId: `${prefix}smug2`, buttonText: {displayText: `>>`}, type: 1},
] */
        let button1ssMessages = {
          image: { url: waifudd.data.url },
          caption: `Here it is...`,
          /*  footer: `${global.BotName}`,
            buttons: wbuttsss,
            headerType: 4 */
        }
        await Phoenix.sendMessage(m.chat, button1ssMessages, { quoted: m }).catch(err => {
          return ('Error!')
        })
        break;







      case 'waifu3':
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!m.isGroup) return reply(mess.grouponly);
        reply(mess.waiting)
        waifudd = await axios.get(`https://nekos.life/api/v2/img/waifu`)
        /*        var wbuttsss = [
{buttonId: `${prefix}waifu3`, buttonText: {displayText: `>>`}, type: 1},
] */
        let button112ssMessages = {
          image: { url: waifudd.data.url },
          caption: `Here it is...`,
          /*   footer: `${global.BotName}`,
             buttons: wbuttsss,
             headerType: 4 */
        }
        await Phoenix.sendMessage(m.chat, button112ssMessages, { quoted: m }).catch(err => {
          return ('Error!')
        })
        break;


      //




      case 'feed':
      case 'meow':
      case 'tickle':
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!m.isGroup) return reply(mess.grouponly);
        reply(mess.waiting)
        waifudd = await axios.get(`https://nekos.life/api/v2/img/${command}`)
        var wbuttsss = [
          { buttonId: `${prefix + command}`, buttonText: { displayText: `>>` }, type: 1 },
        ]
        let buttonssMessages = {
          image: { url: waifudd.data.url },
          caption: `Here it is...`,
          footer: `${global.BotName}`,
          buttons: wbuttsss,
          headerType: 4
        }
        await Phoenix.sendMessage(m.chat, buttonssMessages, { quoted: m }).catch(err => {
          return ('Error!')
        })
        break;



      /////////////////////////////////////////////////////////////////////////////////////////////////////////
      /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



      //
      case 'cry': case 'handhold': {
        if (!isRegistered) return await reply(mess.nonreg, id);

        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!m.isGroup) return reply(mess.grouponly);

        var pat = await fetchJson(`https://api.waifu.pics/sfw/${command}`)
        try {
          let messsender = m.sender
          let musers = ``
          try {
            users = m.mentionedJid[0] ? m.mentionedJid[0] : m.quoted ? m.quoted.sender : text.replace(/[^0-9]/g, '') + '@s.whatsapp.net'

            ment = [messsender, users]
          } catch {
            users == "none"
            ment = [messsender, m.sender]
          }
          if (users == "none") {
            musers = `@${m.sender.split("@")[0]} ${command}ed with themself!`
            console.log(musers)

          } else {
            const rcpp = `@${users.split("@"[0])}`
            musers = `@${m.sender.split("@")[0]} ${command}ed with @${users.split("@")[0]} `

            console.log(musers)
          }
          const response = await axios.get(pat.url, { responseType: 'arraybuffer' })
          const buffer = Buffer.from(response.data, "utf-8")
          var fetchedgif = await GIFBufferToVideoBuffer(buffer)
          Phoenix.sendMessage(m.chat, { video: fetchedgif, gifPlayback: true, mentions: ment, caption: musers }, { quoted: m })
        } catch (error) {
          console.log(error);
        }
      }
        break;


      case 'nom': {
        if (!isRegistered) return await reply(mess.nonreg, id);

        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!m.isGroup) return reply(mess.grouponly);
        var pat = await fetchJson(`https://api.waifu.pics/sfw/${command}`)
        try {
          let messsender = m.sender
          let musers = ``
          try {
            users = m.mentionedJid[0] ? m.mentionedJid[0] : m.quoted ? m.quoted.sender : text.replace(/[^0-9]/g, '') + '@s.whatsapp.net'

            ment = [messsender, users]
          } catch {
            users == "none"
            ment = [messsender, m.sender]
          }
          if (users == "none") {
            musers = `@${m.sender.split("@")[0]} is eating with themself!`
            console.log(musers)

          } else {
            const rcpp = `@${users.split("@"[0])}`
            musers = `@${m.sender.split("@")[0]} is eating with @${users.split("@")[0]} `

            console.log(musers)
          }
          const response = await axios.get(pat.url, { responseType: 'arraybuffer' })
          const buffer = Buffer.from(response.data, "utf-8")
          var fetchedgif = await GIFBufferToVideoBuffer(buffer)
          Phoenix.sendMessage(m.chat, { video: fetchedgif, gifPlayback: true, mentions: ment, caption: musers }, { quoted: m })
        } catch (error) {
          console.log(error);
        }
      }
        break;


      case 'umarmen':
      case 'hug': {
        if (!isRegistered) return await reply(mess.nonreg, id);

        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!m.isGroup) return reply(mess.grouponly);
        var pat = await fetchJson(`https://api.waifu.pics/sfw/hug`)
        try {
          let messsender = m.sender
          let musers = ``
          try {
            users = m.mentionedJid[0] ? m.mentionedJid[0] : m.quoted ? m.quoted.sender : text.replace(/[^0-9]/g, '') + '@s.whatsapp.net'

            ment = [messsender, users]
          } catch {
            users == "none"
            ment = [messsender, m.sender]
          }
          if (users == "none") {
            musers = `@${m.sender.split("@")[0]} hugged themself!`
            console.log(musers)

          } else {
            const rcpp = `@${users.split("@"[0])}`
            musers = `@${m.sender.split("@")[0]} umarmt @${users.split("@")[0]} `

            console.log(musers)
          }
          const response = await axios.get(pat.url, { responseType: 'arraybuffer' })
          const buffer = Buffer.from(response.data, "utf-8")
          var fetchedgif = await GIFBufferToVideoBuffer(buffer)
          Phoenix.sendMessage(m.chat, { video: fetchedgif, gifPlayback: true, mentions: ment, caption: musers }, { quoted: m })
        } catch (error) {
          console.log(error);
        }
      }
        break;


      case 'dance': {
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!m.isGroup) return reply(mess.grouponly);
        var pat = await fetchJson(`https://api.waifu.pics/sfw/${command}`)
        try {
          let messsender = m.sender
          let musers = ``
          try {
            users = m.mentionedJid[0] ? m.mentionedJid[0] : m.quoted ? m.quoted.sender : text.replace(/[^0-9]/g, '') + '@s.whatsapp.net'

            ment = [messsender, users]
          } catch {
            users == "none"
            ment = [messsender, m.sender]
          }
          if (users == "none") {
            musers = `@${m.sender.split("@")[0]} is dancing alone!!`
            console.log(musers)

          } else {
            const rcpp = `@${users.split("@"[0])}`
            musers = `@${m.sender.split("@")[0]} is dancing with @${users.split("@")[0]} `

            console.log(musers)
          }
          const response = await axios.get(pat.url, { responseType: 'arraybuffer' })
          const buffer = Buffer.from(response.data, "utf-8")
          var fetchedgif = await GIFBufferToVideoBuffer(buffer)
          Phoenix.sendMessage(m.chat, { video: fetchedgif, gifPlayback: true, mentions: ment, caption: musers }, { quoted: m })
        } catch (error) {
          console.log(error);
        }
      }
        break;


      //
      case 'kill': case 'pat': case 'lick': case 'kiss': case 'bite':
      case 'bully': case 'bonk': case 'poke': case 'slap':
      case 'happy':
      case 'cuddle': case 'tritt': {

        if (!isRegistered) return await reply(mess.nonreg, id);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!m.isGroup) return reply(mess.grouponly);
        var pat = await fetchJson(`https://api.waifu.pics/sfw/${command}`)
        try {
          let messsender = m.sender
          let musers = ``
          try {
            users = m.mentionedJid[0] ? m.mentionedJid[0] : m.quoted ? m.quoted.sender : text.replace(/[^0-9]/g, '') + '@s.whatsapp.net'

            ment = [messsender, users]
          } catch {
            users == "none"
            ment = [messsender, m.sender]
          }
          if (users == "none") {
            musers = `@${m.sender.split("@")[0]} ${command}ed themselves!!`
            console.log(musers)

          } else {
            const rcpp = `@${users.split("@"[0])}`
            musers = `@${m.sender.split("@")[0]} ${command}ed  @${users.split("@")[0]} `
          }
          const response = await axios.get(pat.url, { responseType: 'arraybuffer' })
          const buffer = Buffer.from(response.data, "utf-8")
          var fetchedgif = await GIFBufferToVideoBuffer(buffer)
          Phoenix.sendMessage(m.chat, { video: fetchedgif, gifPlayback: true, mentions: ment, caption: musers }, { quoted: m })
        } catch (error) {
          console.log(error);
        }
      }
        break;


      case 'yeet':
      case 'wink': case 'smile':
      case 'wave': case 'blush': case 'smug': case 'glomp':
      case 'cringe': case 'highfive': {
        if (!isRegistered) return await reply(mess.nonreg, id);

        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!m.isGroup) return reply(mess.grouponly);
        var pat = await fetchJson(`https://api.waifu.pics/sfw/${command}`)
        try {
          let messsender = m.sender
          let musers = ``
          try {
            users = m.mentionedJid[0] ? m.mentionedJid[0] : m.quoted ? m.quoted.sender : text.replace(/[^0-9]/g, '') + '@s.whatsapp.net'

            ment = [messsender, users]
          } catch {
            users == "none"
            ment = [messsender, m.sender]
          }
          if (users == "none") {
            musers = `@${m.sender.split("@")[0]} ${command}ed at themself!`
            console.log(musers)

          } else {
            const rcpp = `@${users.split("@"[0])}`
            musers = `@${m.sender.split("@")[0]} ${command}ed at @${users.split("@")[0]} `

            console.log(musers)
          }
          const response = await axios.get(pat.url, { responseType: 'arraybuffer' })
          const buffer = Buffer.from(response.data, "utf-8")
          var fetchedgif = await GIFBufferToVideoBuffer(buffer)
          Phoenix.sendMessage(m.chat, { video: fetchedgif, gifPlayback: true, mentions: ment, caption: musers }, { quoted: m })
        } catch (error) {
          console.log(error);
        }
      }
        break;










      case 'animewall2': case 'animewallpaper2':
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!m.isGroup) return reply(mess.grouponly);
        reply(mess.waiting)
        const { AnimeWallpaper } = require("anime-wallpaper")
        if (!q) return reply('Please enter a seach term!')
        const wall = new AnimeWallpaper();
        const pages = [1, 2, 3, 4];
        const random = pages[Math.floor(Math.random() * pages.length)]
        const wallpaper = await wall
          .getAnimeWall4({ title: q, type: "sfw", page: pages })
          .catch(() => null);
        const i = Math.floor(Math.random() * wallpaper.length);
        var walb = [
          { buttonId: `${prefix}animewall2 ${q}`, buttonText: { displayText: `>>` }, type: 1 },
        ]
        let wal = {
          image: { url: wallpaper[i].image },
          caption: `*Suchbegriff :* ${q}`,
          footer: `${global.BotName}`,
          buttons: walb,
          headerType: 4
        }
        await Phoenix.sendMessage(m.chat, wal, { quoted: m }).catch(err => {
          return ('Error!')
        })
        break;



      //
      case 'anime': {
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!m.isGroup) return reply(mess.grouponly);
        if (!text) return m.reply(`Please provide a Suchbegriff!\n\n*Beispiel:* ${prefix}anime naruto`)

        const malScraper = require('mal-scraper')
        reply(mess.waiting);
        const anime = await malScraper.getInfoFromName(text).catch(() => null)
        if (!anime) return m.reply(`${p}Could not find your scarch`)
        let animetxt = `
  🎀 *Title: ${anime.title}*
  🎋 *Type: ${anime.type}*
  🎐 *Premiered on: ${anime.premiered}*
  💠 *Total Episodes: ${anime.episodes}*
  📈 *Status: ${anime.status}*
  💮 *Genres: ${anime.genres}
  📍 *Studio: ${anime.studios}*
  🌟 *Score: ${anime.score}*
  💎 *Rating: ${anime.rating}*
  🏅 *Rank: ${anime.ranked}*
  💫 *Popularity: ${anime.popularity}*
  ♦️ *Trailer: ${anime.trailer}*
  🌐 *URL: ${anime.url}*
  ❄ *Description:* ${anime.synopsis}*`
        await Phoenix.sendMessage(m.chat, { image: { url: anime.picture }, caption: animetxt }, { quoted: m })
      }
        break;


      case 'manga':
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!m.isGroup) return reply(mess.grouponly);

        reply(mess.waiting)
        const { Manga } = require("@shineiichijo/marika")
        const manga = new Manga();
        if (!q) return m.reply(`Please proide a Suchbegriff!\n\n_Beispiel:_ ${prefix}manga naruto`)
        let srh = await manga.searchManga(q)
        let mang = `*Title:* ${srh.data[0].title}\n`;
        mang += `*Status:* ${srh.data[0].status}\n`;
        mang += `*Total Volumes:* ${srh.data[0].volumes}\n`;
        mang += `*Total Chapters:* ${srh.data[0].chapters}\n`;
        mang += `*Genres:*\n`;
        for (let i = 0; i < srh.data[0].genres.length; i++) {
          mang += `\t\t\t\t\t\t\t\t${srh.data[0].genres[i].name}\n`;
        }
        mang += `*Published on:* ${srh.data[0].published.from}\n`;
        mang += `*Score:* ${srh.data[0].scored}\n`;
        mang += `*Popularity:* ${srh.data[0].popularity}\n`;
        mang += `*Favorites:* ${srh.data[0].favorites}\n`;
        mang += `*Authors:*\n`;
        for (let i = 0; i < srh.data[0].authors.length; i++) {
          mang += `\t\t\t\t\t\t\t\t\t${srh.data[0].authors[i].name} (${srh.data[0].authors[0].type})\n`;
        }
        mang += `\n*URL:* ${srh.data[0].url}\n\n`;
        if (srh.data[0].background !== null)
          mang += `*Background:* ${srh.data[0].background}`;
        mang += `*Description:* ${srh.data[0].synopsis.replace(
          /\[Written by MAL Rewrite]/g,
          ""
        )}`;
        Phoenix.sendMessage(m.chat, { image: { url: srh.data[0].images.jpg.large_image_url }, caption: mang }, { quoted: m })
        break;


      case 'waifu':
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!m.isGroup) return reply(mess.grouponly);
        reply(mess.waiting)
        waifuddd = await axios.get('https://waifu.pics/api/sfw/waifu')
        /*var wbuttsssr = [
          {buttonId: `${prefix}waifu`, buttonText: {displayText: `>>`}, type: 1},
          ] */
        let button4Messagess = {
          image: { url: waifuddd.data.url },
          caption: 'More than one waifu will definitely ruin your Laifu!',
          /*buttons: wbuttsssr,
          headerType: 4 */
        }

        await Phoenix.sendMessage(m.chat, button4Messagess, { quoted: m }).catch(err => {
          return ('error..')
        })
        break;







      ////////////////////////////////////////////////////////////////////////////
      ////////////////////////////////////////////////////////////////////////////



      case 'remove':
      case 'geh':
      case 'weg':
      case 'kickk':
        {
          if (!isRegistered) return await reply(mess.nonreg, id);

          if (!m.isGroup) return reply(mess.grouponly);
          if (!isBotAdmins) return reply(mess.botadmin);
          if (!isAdmins && !isCreator) return reply(mess.useradmin)
          let users = m.mentionedJid[0] ? m.mentionedJid[0] : m.quoted ? m.quoted.sender : text.replace(/[^0-9]/g, '') + '@s.whatsapp.net'
          await Phoenix.groupParticipantsUpdate(m.chat, [users], 'remove')
        }
        break;

        
        case 'add': {
          if (!isRegistered) return await reply(mess.nonreg, id);
          if (!m.isGroup) return reply(mess.grouponly);
          if (!isBotAdmins) return reply(mess.botadmin);
          if (!isCreator) return reply(mess.botowner);
      
          let userss;
          if (m.mentionedJid.length > 0) {
              userss = m.mentionedJid[0];
          } else if (m.quoted && m.quoted.sender) {
              userss = m.quoted.sender;
          } else {
              // Extract numbers from text and format them properly
              const number = text.replace(/[^0-9]/g, '');
              userss = `${number}@s.whatsapp.net`;
          }
      
          console.log(userss);
          await reply(`Die Nummer ${userss} wurde erkannt, aber der Bot fügt sie nicht zur Gruppe hinzu. (Banngefahr!)`);
      }
      break;
      
      




      /*
            case 'bc': case 'broadcast': case 'bcall': {
              if (!isRegistered) return await reply(mess.nonreg, id);
              if (isBan) return reply(mess.banned);
              if (isBanChat) return reply(mess.bangc);
              if (!isCreator) return reply(mess.botowner)
              if (!args.join(" ")) return m.reply(`Please enter some text to broadcast! \n\nBeispiel : ${prefix + command} ${global.OwnerName}`)
              let anu = await store.chats.all().map(v => v.id)
              m.reply(`Send Broadcast To ${anu.length} Chat\nTime's up ${anu.length * 1.5} second`)
              for (let yoi of anu) {
                await sleep(1500)
                let btn = [{
                  quickreplyButton: {
                    displayText: '💡 Menu 💡',
                    id: '-menu'
                  }
                }, {
                  quickreplyButton: {
                    displayText: 'Bot Owner',
                    id: '-owner'
                  }
                }]
                let txt = `「 *${global.OwnerName}'s Broadcast* 」\n\n${text}`
                Phoenix.send5ButImg(yoi, txt, `${global.BotName}`, BotLogo, btn, Thumb)
              }
              reply('Broadcast Sent !')
            }
              break;
      */



      case 'help': case 'start': case 'h': case 'menu': case 'list': {
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        const helpmenu = ` 
┌──『•• 🛠 *ᴍᴇɴᴜ* 🛠 ••』──◈
│╭────────────···▸▸
┴│
  │⊳  *Uꜱᴇʀ :  ${pushname}* ✅
  │⊳  *Uhrzeit : ${kaitime}* ⌚
  │⊳  *Datum : ${kaidate}* 📆
  │⊳  *Oᴡɴᴇʀ : ${global.OwnerName}* 👑
  │⊳  *Pʀᴇꜰɪx : 『  ${prefix} 』* ⚙️
  │⊳  *Laufzeit :* *${runtime(process.uptime())}* 
  │⊳  *Entwickelt von Team-Phoenix* 
┬│   
│╰───────────···▸▸
└──────────────···▸▸▸
┌──『•• 🛠 *ᴍᴇɴᴜ* 🛠 ••』──◈
│╭────────────···▸▸
┴│
  │⊳ *${prefix}1.1*  *ʙᴏᴛᴍᴇɴᴜ*
  │⊳ *${prefix}1.2*  *ᴏᴡɴᴇʀᴍᴇɴᴜ*
  │⊳ *${prefix}1.3*  *ɢʀᴏᴜᴘᴍᴇɴᴜ*
  │⊳ *${prefix}1.4*  *ᴀɴᴛɪʟɪɴᴋ*
  │⊳ *${prefix}1.5*  *Eᴄᴏɴᴏᴍʏ*
  │⊳ *${prefix}1.6*  *ᴄᴏɴᴠᴇʀᴛ*
  │⊳ *${prefix}1.7*  *ᴅᴏᴡɴʟᴏᴀᴅᴇʀ*
  │⊳ *${prefix}1.8*  *ɢᴀᴍᴇ/Fun*
┬│
│╰───────────···▸▸
└──────────────···▸▸▸`
        let buttonMessage = {
          image: fs.readFileSync('./Assets/pic1.jpg'),
          caption: helpmenu,

        }
        let msg = generateWAMessageFromContent(from, {
          viewOnceMessage: {
            message: {
              "messageContextInfo": {
                "deviceListMetadata": {},
                "deviceListMetadataVersion": 2
              },
              interactiveMessage: proto.Message.InteractiveMessage.create({
                body: proto.Message.InteractiveMessage.Body.create({
                  text: helpmenu,
                  image: { url: global.BotLogo }

                }),
                footer: proto.Message.InteractiveMessage.Footer.create({
                  text: "_Entwickelt von Team-Phoenix_"
                }),
                header: proto.Message.InteractiveMessage.Header.create({
                  title: BotName,
                  subtitle: "",

                  hasMediaAttachment: false
                }),
                nativeFlowMessage: proto.Message.InteractiveMessage.NativeFlowMessage.create({
                  buttons: [
                    {
                      "name": "single_select",
                      "buttonParamsJson":
                        `{"title":"List Menu ⎙",
"sections":[{"title":"Phoenix-Bot",
"highlight_label": "Favorite Request",
"rows":[
  {"title":"Ping",
"description":"${prefix}ping",
"id":"${prefix}ping"},

{"title":"ʙᴏᴛᴍᴇɴᴜ",
  "description":"${prefix}1.1",
  "id":"${prefix}1.1"},


  {"title":"ᴏᴡɴᴇʀᴍᴇɴᴜ",
  "description":"${prefix}1.2",
  "id":"${prefix}1.2"},

  {"title":"ɢʀᴏᴜᴘᴍᴇɴᴜ",
  "description":"${prefix}1.3",
  "id":"${prefix}1.3"},

  {"title":"ᴀɴᴛɪʟɪɴᴋ",
  "description":"${prefix}1.4",
  "id":"${prefix}1.4"},

  {"title":"Eᴄᴏɴᴏᴍʏ",
  "description":"${prefix}1.5",
  "id":"${prefix}1.5"},

  {"title":"ᴄᴏɴᴠᴇʀᴛ",
  "description":"${prefix}1.6",
  "id":"${prefix}1.6"},

  {"title":"ᴅᴏᴡɴʟᴏᴀᴅᴇʀ",
  "description":"${prefix}1.7",
  "id":"${prefix}1.7"},

  {"title":"ɢᴀᴍᴇ/Fun",
  "description":"${prefix}1.8",
  "id":"${prefix}1.8"},

  {
"title":"Group",
"description":"${prefix}Group open/close",
"id":"${prefix}group"},


{
"title":"Hidetag",
"id":"${prefix}hidetag"}

]
}]
}`
                    },
                  ],


                }),
                contextInfo: {
                  image: { url: global.BotLogo },
                  mentionedJid: [m.sender],
                  forwardingScore: 9999,
                  isForwarded: false,
                  thumbnailUrl: 'https://i.ibb.co/tMjD0Xb/pic4.jpg',
                  sourceUrl: global.link,

                }
              })
            }
          }
        }, {})
        await Phoenix.relayMessage(msg.key.remoteJid, msg.message, {
          messageId: msg.key.id
        })
        // Phoenix.sendMessage(m.chat, buttonMessage, {contextInfo: {externalAdReply: {  sourceUrl: global.link} }}, { quoted: m })
      }
        break;


      case 'alive':
        if (isCmd) {
          if (isBan) return reply(mess.banned);
          if (isBanChat) return reply(mess.bangc);

          m.reply(`
┌──『•• 👀 *ᴀʟɪᴠᴇ* 👀 ••』──◈
│╭────────────···▸▸
┴│
  │⊳  *Uꜱᴇʀ :  ${pushname}* ✅
  │⊳  *Uhrzeit : ${kaitime}* ⌚
  │⊳  *Datum : ${kaidate}* 📆
  │⊳  *Oᴡɴᴇʀ : ${global.OwnerName}* 👑
  │⊳  *Pʀᴇꜰɪx : 『 ${prefix} 』*  ⚙️
  │⊳  *Laufzeit : ${runtime(process.uptime())}* 
  │⊳  *Entwickelt von Team-Phoenix* 
┬│   
│╰───────────···▸▸
└──────────────···▸▸▸`)
        }

        break;


      case '1.1': case 'botmenu':
        if (isCmd) {
          if (!isRegistered) return await reply(mess.nonreg, id);
          if (isBan) return reply(mess.banned);
          if (isBanChat) return reply(mess.bangc);

          m.reply(`
┌──『•• 🤖 *Bᴏᴛ-Mᴇɴᴜ* 🤖 ••』──◈
│╭────────────···▸▸
┴│
⬡│▸ ${prefix}ᴄᴏᴍ
⬡│▸ ${prefix}ᴘɪɴɢ
⬡│▸ ${prefix}ᴀʟɪᴠᴇ
⬡│▸ ${prefix}sᴇʀvᴇʀ
⬡│▸ ${prefix}ꜱʏꜱɪɴғᴏ
⬡│▸ ${prefix}ʟᴇᴠᴇʟ
⬡│▸ ${prefix}ᴛᴇᴀᴍ
⬡│▸ ${prefix}ꜱᴜᴘᴘᴏʀᴛ
⬡│▸ ${prefix}ꜱᴜᴘᴘᴏʀᴛɢᴄ
⬡│▸ ${prefix}ꜱᴘᴇᴇᴅᴄʜᴇᴄᴋ
⬡│▸ ${prefix}ꜱᴘᴇᴀᴋ
⬡│▸ ${prefix}ꜱᴛᴀʟᴋ
⬡│▸ ${prefix}ꜱᴇᴛᴘʀᴇꜰɪx
⬡│▸ ${prefix}ᴀᴜᴛᴏ-ᴛʏᴘɪɴɢ  
⬡│▸ ${prefix}ᴀᴜᴛᴏ-ꜱᴛᴀᴛᴜꜱ
⬡│▸ ${prefix}ᴀᴜᴛᴏ-ʀᴇᴄᴏʀᴅɪɴɢ 
┬│
│╰───────────···▸▸
└──────────────···▸▸▸`)
        }

        break;



      case '1.2': case 'ownermenu':
        if (isCmd) {
          if (!isRegistered) return await reply(mess.nonreg, id);
          if (!isCreator) return reply(mess.botowner)
          if (isBan) return reply(mess.banned);
          if (isBanChat) return reply(mess.bangc);

          m.reply(`
┌──『•• 👑 *Oᴡɴᴇʀ* 👑 ••』───◈
│╭────────────···▸▸
┴│
⬡│▸ ${prefix}ᴜsᴇʀ
⬡│▸ ${prefix}ᴘᴜʙʟɪᴄ
⬡│▸ ${prefix}ꜱᴇʟꜰ
⬡│▸ ${prefix}ʀᴇꜱᴛᴀʀᴛ
⬡│▸ ${prefix}ꜱᴇᴛʙᴏᴛᴘᴘ
⬡│▸ ${prefix}ꜱʟᴇᴇᴘ
⬡│▸ ${prefix}ᴊᴏɪɴ
⬡│▸ ${prefix}ᴘᴏꜱᴛ
⬡│▸ ${prefix}ʟɪꜱᴛɢᴄ
⬡│▸ ${prefix}ʟɪꜱᴛᴘᴄ
⬡│▸ ${prefix}ʟɪꜱᴛᴏɴʟɪɴᴇ 
⬡│▸ ${prefix}ʙʀᴏᴀᴅᴄᴀꜱᴛ
⬡│▸ ${prefix}ʙᴀɴɢʀᴏᴜᴘ 
⬡│▸ ${prefix}ʙʟᴏᴄᴋ
⬡│▸ ${prefix}ᴜɴʙʟᴏᴄᴋ
⬡│▸ ${prefix}ʙᴀɴ ᴀᴅᴅ
⬡│▸ ${prefix}ʙᴀɴ ᴅᴇʟ
┬│
│╰───────────···▸▸
└──────────────···▸▸▸`)
        }

        break;



      case '1.3': case 'groupmenu':
        if (isCmd) {
          if (!isRegistered) return await reply(mess.nonreg, id);
          if (isBan) return reply(mess.banned);
          if (isBanChat) return reply(mess.bangc);

          m.reply(`
┌──『•• 🎯 *Gʀᴏᴜᴘ* 🎯 ••』───◈
│╭────────────···▸▸
┴│
⬡│▸ ${prefix}ᴘʀᴏᴍᴏᴛᴇ  
⬡│▸ ${prefix}ᴅᴇᴍᴏᴛᴇ  
⬡│▸ ${prefix}ɢʀᴏᴜᴘ-ᴇᴠᴇɴᴛ  
⬡│▸ ${prefix}ɢʀᴏᴜᴘsᴇᴛᴛɪɴɢs
⬡│▸ ${prefix}ɢʀᴏᴜᴘʟɪɴᴋ
⬡│▸ ${prefix}ʀᴇᴍᴏᴠᴇ 
⬡│▸ ${prefix}ꜱᴇᴛɴᴀᴍᴇ
⬡│▸ ${prefix}ꜱᴇᴛɢᴄᴘᴘ
⬡│▸ ${prefix}ꜱᴇᴛᴅᴇꜱᴄ
⬡│▸ ${prefix}ʀᴇᴠᴏᴋᴇ
⬡│▸ ${prefix}ᴛᴀɢᴀᴅᴍɪɴꜱ (mit text)
⬡│▸ ${prefix}ᴛᴀɢᴀʟʟ
⬡│▸ ${prefix}ʜɪᴅᴇᴛᴀɢ
⬡│▸ ${prefix}ɴꜱꜰᴡ  
┬│
│╰───────────···▸▸
└──────────────···▸▸▸`)
        }

        break;


      case '1.4': case 'antilinkmenu':
        if (isCmd) {
          if (!isRegistered) return await reply(mess.nonreg, id);
          if (isBan) return reply(mess.banned);
          if (isBanChat) return reply(mess.bangc);

          m.reply(`
┌──『•• ❌ *Aɴᴛɪ-Lɪɴᴋ* ❌ ••』───◈
│╭────────────···▸▸
┴│
⬡│▸  ${prefix}ᴀɴᴛɪʟɪɴᴋ     
⬡│▸  ${prefix}ᴀɴᴛɪʟɪɴᴋᴀʟʟ     
┬│
│╰────────────···▸▸
└───────────────···▸▸▸`)
        }

        break;


      case '1.5': case 'economymenu':
        if (isCmd) {
          if (!isRegistered) return await reply(mess.nonreg, id);
          if (isBan) return reply(mess.banned);
          if (isBanChat) return reply(mess.bangc);

          m.reply(`
┌──『•• 🎯 *Eᴄᴏɴᴏᴍʏ* 🎯 ••』───◈
│╭───────────···▸▸
┴│
⬡│▸  ${prefix}ᴅᴀɪʟʏ 
⬡│▸  ${prefix}Wetter
⬡│▸  ${prefix}ᴡᴀʟʟᴇᴛ 
⬡│▸  ${prefix}ʙᴀɴᴋ
⬡│▸  ${prefix}ʙᴀɴᴋᴜᴘɢʀᴀᴅᴇ 
⬡│▸  ${prefix}ᴅᴇᴘᴏꜱɪᴛ
⬡│▸  ${prefix}ᴡɪᴛʜᴅʀᴀᴡ
⬡│▸  ${prefix}ʀᴏʙ / ᴀᴛᴛᴀᴄᴋ 
⬡│▸  ${prefix}ᴛʀᴀɴꜱꜰᴇʀ / ɢɪᴠᴇ 
⬡│▸  ${prefix}ᴡᴇᴀʟᴛʜ / ʀɪᴛᴜᴀʟ 
┬│
│╰───────────···▸▸
└───────────────···▸▸▸`)
        }

        break;


      case '':
        if (isCmd) {
          if (isBan) return reply(mess.banned);
          if (isBanChat) return reply(mess.bangc);

          m.reply(`│𝐏𝐇𝐎𝐄𝐍𝐈𝐗│𝐁𝐎𝐓│𝐕1️⃣ 🌃`)
        }

        break;



      case '1.6': case 'convertmenu':
        if (isCmd) {
          if (!isRegistered) return await reply(mess.nonreg, id);
          if (isBan) return reply(mess.banned);
          if (isBanChat) return reply(mess.bangc);

          m.reply(`
┌──『•• 🎯 *Cᴏɴᴠᴇʀᴛ* 🎯 ••』───◈
│╭─────────────···▸▸
┴│
⬡│▸  ${prefix}ꜱᴛɪᴄᴋᴇʀ 
⬡│▸  ${prefix}ᴛᴏɢɪꜰ
⬡│▸  ${prefix}ᴜʀʟ
⬡│▸  ${prefix}ᴛᴏᴍᴘ3
⬡│▸  ${prefix}ᴛᴏᴀᴜᴅɪᴏ
⬡│▸  ${prefix}ᴇᴍᴏᴊɪᴍɪx 
⬡│▸  ${prefix}ꜱᴛᴇᴀʟ
┬│
│╰────────────···▸▸`)
        }

        break;


      case '':
        if (isCmd) {
          if (isBan) return reply(mess.banned);
          if (isBanChat) return reply(mess.bangc);

          m.reply(``)
        }

        break;


      case '':
        if (isCmd) {
          if (isBan) return reply(mess.banned);
          if (isBanChat) return reply(mess.bangc);

          m.reply(`│𝐏𝐇𝐎𝐄𝐍𝐈𝐗│𝐁𝐎𝐓│𝐕1️⃣ 🌃`)
        }

        break;


      case '1.7': case 'downloadermenu':
        if (isCmd) {
          if (!isRegistered) return await reply(mess.nonreg, id);
          if (isBan) return reply(mess.banned);
          if (isBanChat) return reply(mess.bangc);

          m.reply(`
┌─『•• 📥 *Dᴏᴡɴʟᴏᴀᴅᴇʀ* 📥 ••』─◈
│╭────────────···▸▸
⬡│▸  ${prefix}ᴘʟᴀʏ
⬡│▸  ${prefix}ꜱᴏɴɢ
⬡│▸  ${prefix}ᴠɪᴅᴇᴏ
⬡│▸  ${prefix}ʏᴛᴍᴘ3
⬡│▸  ${prefix}ʏᴛᴍᴘ4
⬡│▸  ${prefix}ᴍᴏᴠɪᴇ
⬡│▸  ${prefix}ᴡᴀʟʟᴘᴀᴘᴇʀ
⬡│▸  ${prefix}ɪᴍᴀɢᴇ
⬡│▸  ${prefix}ꜱᴇᴀʀᴄʜ
⬡│▸  ${prefix}ʏᴛᴠɪᴅᴇᴏ
⬡│▸  ${prefix}ᴍᴇᴅɪᴀꜰɪʀᴇ
⬡│▸  ${prefix}ɪɴꜱᴛᴀɢʀᴀᴍ
⬡│▸  ${prefix}ꜰᴀᴄᴇʙᴏᴏᴋ
⬡│▸  ${prefix}ꜰʙᴍᴘ3
⬡│▸  ${prefix}ᴛɪᴋᴛᴏᴋ
│╰───────────···▸▸
└──────────────···▸▸▸`)
        }

        break;


      case '1.8': case 'gamesmenu': case 'funmenu':
        if (isCmd) {
          if (!isRegistered) return await reply(mess.nonreg, id);
          if (isBan) return reply(mess.banned);
          if (isBanChat) return reply(mess.bangc);

          m.reply(`
┌──『•• 🎮 *Game* / *Fun* 🤡••』───◈
│╭────────────···▸▸
┴│
⬡│▸ ${prefix}ʜᴏᴛᴄʜᴇᴄᴋ
⬡│▸ ${prefix}ɢᴀʏᴄʜᴇᴄᴋ
⬡│▸ ${prefix}ʜᴜʀᴇɴsᴏʜɴ
⬡│▸ ${prefix}sᴛᴜᴘɪᴅᴄʜᴇᴄᴋ
⬡│▸ ${prefix}ᴛᴛᴛ / ᴛɪᴄᴛᴀᴄᴛᴏᴇ    
⬡│▸ ${prefix}ɢᴀᴍʙʟᴇ / ʟᴏᴛᴛᴇʀʏ
⬡│▸ ${prefix}ꜱᴘɪɴ / ꜱʟᴏᴛ  
┬│
│╰───────────···▸▸`)
        }

        break;





      case '':
        if (isCmd) {
          if (isBan) return reply(mess.banned);
          if (isBanChat) return reply(mess.bangc);

          m.reply(`│𝐏𝐇𝐎𝐄𝐍𝐈𝐗│𝐁𝐎𝐓│𝐕1️⃣ 🌃`)
        }

        break;


      case '':
        if (isCmd) {
          if (isBan) return reply(mess.banned);
          if (isBanChat) return reply(mess.bangc);

          m.reply(`│𝐏𝐇𝐎𝐄𝐍𝐈𝐗│𝐁𝐎𝐓│🌃`)
        }

        break;
      case 'gaycheck-onyx':
        if (isCmd) {
          if (!isRegistered) return await reply(mess.nonreg, id);
          if (isBan) return reply(mess.banned);
          if (isBanChat) return reply(mess.bangc);
          m.reply(`Hey *${pushname}*,  Ja Onyx ist Schwul aber sowas ist Völlig normal. :)`)
        }

        break;


      case 'ping':
        if (isCmd) {
          if (!isRegistered) return await reply(mess.nonreg, id);
          if (isBan) return reply(mess.banned);
          if (isBanChat) return reply(mess.bangc);

          let start = new Date;
          await m.reply(`Bitte warte einen Augenblick, bis die Geschwindigkeit berechnet wurde...`);
          let done = new Date - start;
          await reply(`\n╭──────────────────────╮\n│   *Aloha! ${pushname}* \n│  📡 *Pong!*\n│  🚀 *Geschwindigkeit*:\n│  ⏱️ ${done}ms (${Math.round(done / 100) / 10}s)\n╰──────────────────────╯
            `);
                    }
        break;




      //////search
      case 'wetter':
        if (!isRegistered) return await reply(mess.nonreg, id);
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        if (!args[0]) return reply("Gebe bitte deinen Standort ein.")
        myweather = await axios.get(`https://api.openweathermap.org/data/2.5/weather?q=${args.join(" ")}&units=metric&appid=e409825a497a0c894d2dd975542234b0&language=tr`)

        const weathertext = `           🌤 *Wetterbericht* 🌤  \n\n🔎 *Suchbereich:* ${myweather.data.name}\n*💮 Land:* ${myweather.data.sys.country}\n🌈 *Wetter:* ${myweather.data.weather[0].description}\n🌡️ *Temperature:* ${myweather.data.main.temp}°C\n❄️ *Minimum Temperature:* ${myweather.data.main.temp_min}°C\n📛 *Maximum Temperature:* ${myweather.data.main.temp_max}°C\n💦 *Humidity:* ${myweather.data.main.humidity}%\n🎐 *Wind:* ${myweather.data.wind.speed} km/h\n`
        Phoenix.sendMessage(from, { video: { url: 'https://media.tenor.com/bC57J4v11UcAAAPo/weather-sunny.mp4' }, gifPlayback: true, caption: weathertext }, { quoted: m })

        break;




      case 'stupidcheck':
      case 'uncleancheck':
      case 'hotcheck':
      case 'smartcheck':
      case 'greatcheck':
      case 'evilcheck':
      case 'dogcheck':
      case 'coolcheck':
      case 'waifucheck':
        if (!isRegistered) return await reply(mess.nonreg, id);
        cantik = body.slice(1)
        const okebnh1 = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '90', '91', '92', '93', '94', '95', '96', '97', '98', '99', '100']
        const Phoenixkak = okebnh1[Math.floor(Math.random() * okebnh1.length)]
        Phoenix.sendMessage(m.chat, { text: Phoenixkak }, { quoted: m })
        break;




      ///////////////////////////////////////////////////
      ///////////////////////////////////////////////////




      default:


      if (isCmd) {
        if (isBan) return reply(mess.banned);
        if (isBanChat) return reply(mess.bangc);
        m.reply(`Hey ${pushname} *Dieser Befehl ist nicht Vorhanden... Nutze ${prefix}menu um weitere Befehle zu sehen.*`)

      }
    
    


        if (budy.startsWith('=>')) {
          if (!isCreator) return reply(mess.botowner)
          function Return(sul) {
            sat = JSON.stringify(sul, null, 2)
            bang = util.format(sat)
            if (sat == undefined) {
              bang = util.format(sul)
            }
            return reply(bang)
          }
          try {
            reply(util.format(eval(`(async () => { ${budy.slice(3)} })()`)))
          } catch (e) {
            Phoenix.sendMessage(from, { image: ErrorPic, caption: String(e) }, { quoted: m })
          }
        }


        // if (isCmd && budy.toLowerCase() != undefined) {
        //   if (m.chat.endsWith('broadcast')) return
        //   if (m.isBaileys) return
        //   let msgs = global.db.database
        //   if (!(budy.toLowerCase() in msgs)) return
        //   Phoenix.copyNForward(m.chat, msgs[budy.toLowerCase()], true)
        // }
    }
  } catch (err) {
    Phoenix.sendMessage(`436649151729@s.whatsapp.net`, util.format(err), { quoted: m })
    console.log(err)
  }

}
let file = require.resolve(__filename)
fs.watchFile(file, () => {
  fs.unwatchFile(file)
  console.log(chalk.redBright(`Update ${__filename}`))
  delete require.cache[file]
  require(file)
})


